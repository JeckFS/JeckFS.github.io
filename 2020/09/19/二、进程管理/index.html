<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>二、进程管理 | JeckFS</title><meta name="keywords" content="王道操作系统"><meta name="author" content="YFS"><meta name="copyright" content="YFS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程与线程1.进程的概念与特征概念：  进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的独立单位。  特征：  动态性 并发性 独立性 异步性 结构性：程序段、数据段、PCB  2.进程的状态与转换运行状态就绪状态：获得了除处理机之外一切的所需资源，一旦得到处理机即可运行。阻塞状">
<meta property="og:type" content="article">
<meta property="og:title" content="二、进程管理">
<meta property="og:url" content="http://jeckfs.gitee.io/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="JeckFS">
<meta property="og:description" content="进程与线程1.进程的概念与特征概念：  进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的独立单位。  特征：  动态性 并发性 独立性 异步性 结构性：程序段、数据段、PCB  2.进程的状态与转换运行状态就绪状态：获得了除处理机之外一切的所需资源，一旦得到处理机即可运行。阻塞状">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=2322041376,2548191196&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2020-09-19T07:25:51.000Z">
<meta property="article:modified_time" content="2022-12-09T12:36:58.466Z">
<meta property="article:author" content="YFS">
<meta property="article:tag" content="王道操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=2322041376,2548191196&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/JeckFS/img/favicon.png"><link rel="canonical" href="http://jeckfs.gitee.io/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/JeckFS/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/JeckFS/',
  algolia: undefined,
  localSearch: {"path":"/JeckFS/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二、进程管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-09 20:36:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">248</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=2322041376,2548191196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/JeckFS/">JeckFS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二、进程管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-19T07:25:51.000Z" title="发表于 2020-09-19 15:25:51">2020-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-09T12:36:58.466Z" title="更新于 2022-12-09 20:36:58">2022-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/JeckFS/categories/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">王道操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二、进程管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.png" class="" title="This is 1-th image.">
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="1-进程的概念与特征"><a href="#1-进程的概念与特征" class="headerlink" title="1.进程的概念与特征"></a>1.进程的概念与特征</h2><p>概念：</p>
<ul>
<li>进程是程序的一次执行过程。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行<strong>资源分配和调度的独立单位</strong>。</li>
</ul>
<p>特征：</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
<li>结构性：程序段、数据段、PCB</li>
</ul>
<h2 id="2-进程的状态与转换"><a href="#2-进程的状态与转换" class="headerlink" title="2.进程的状态与转换"></a>2.进程的状态与转换</h2><p><strong>运行状态</strong><br><strong>就绪状态</strong>：获得了除处理机之外一切的所需资源，一旦得到处理机即可运行。<br><strong>阻塞状态/等待状态</strong>：等待某事件发生，或等待某资源可用，或等待输入/输出完成。<br><strong>创建状态</strong>：申请空白PCB，并向PCB填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所需的资源；最后把该进程转入到就绪状态。<br><strong>结束状态</strong></p>
<p>由于进程得到处理机的时间很短且非常频繁，所以进程在运行过程中实际上是频繁地转换到就绪状态。相对而言，其他资源（如外设）的使用和分配，或某一事件的发生（如IO操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.png" class="" title="This is 2-th image.">
<p>运行状态到阻塞状态，用户程序会由用户态进入到内核态。</p>
<h2 id="3-进程的控制"><a href="#3-进程的控制" class="headerlink" title="3.进程的控制"></a>3.进程的控制</h2><p>进程控制用的程序段都是原语。</p>
<p>作业调度、系统提供服务、用户程序的应用请求都会创建进程。</p>
<p><strong>进程的创建、终止、切换都需要转入到内核态中完成。</strong></p>
<ul>
<li>进程的创建（创建原语）<ol>
<li>为新线程分配一个唯一的进程标识号，并申请一个空白的PCB。</li>
<li>为新进程的程序、数据、用户栈分配必要的内存空间。如果资源不足则进入阻塞状态。</li>
<li>初始化PCB，如PCB的标志信息、处理机状态信息、处理机控制信息、进程优先级等。</li>
<li>若就绪队列能够接纳新线程，则将新线程插入到就绪队列，等待调度。</li>
</ol>
</li>
<li>进程的终止（撤销原语）</li>
<li>进程的阻塞和唤醒（阻塞原语、唤醒原语）</li>
<li>进程切换</li>
</ul>
<p>引起进程终止的情况：</p>
<ul>
<li>正常结束</li>
<li>发生了某种异常事件：存储区越界、保护错、非法指令、特权指令错、IO故障等。</li>
<li>外界干预：操作员或操作系统干预、父进程请求和父进程终止。</li>
</ul>
<p>进程阻塞时要保护其现场，并将该进程PCB插入到相应事件的等待队列中。<br>进程唤醒时将线程PCB从等待队列中移出并插入到就绪队列中，等待调度。</p>
<p>阻塞原语是有被阻塞进程的<strong>自我调用</strong>实现的。<br>唤醒原语是由一个与被唤醒进程相合作，或被其他相关进程调用实现的。</p>
<p>进程的切换：</p>
<ul>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移动到相应的队列。</li>
<li>调度另一进程，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理机上下文。</li>
</ul>
<p><strong>进程切换与处理模式切换：</strong><br>模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到内核态运行，执行完后又回到用户态刚被中断的程序中运行，则操作系统只需恢复进入内核时所保存的CPU现场，无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p>
<h2 id="4-进程的组织"><a href="#4-进程的组织" class="headerlink" title="4.进程的组织"></a>4.进程的组织</h2><p><strong>1.PCB</strong><br>PCB常驻内存，它是进程实体的一部分，是进程存在的唯一标识。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.png" class="" title="This is 3-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.png" class="" title="This is 4-th image.">
<p>PCB的组织方式：</p>
<ul>
<li>链接方式：同一状态的PCB链接成一个队列，不同状态对应不同的队列。也可以根据阻塞原因的不同，排成多个阻塞队列。</li>
<li>索引方式：同一状态的PCB组织在一个索引表中，索引表的表项指向响应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li>
</ul>
<p><strong>2.程序段</strong><br>即CPU执行的程序代码段。程序可被多个进程共享。</p>
<p><strong>3.数据段</strong><br>程序加工处理的原始数据、程序执行时产生的中间或最终结果。</p>
<h2 id="5-进程的通信"><a href="#5-进程的通信" class="headerlink" title="5.进程的通信"></a>5.进程的通信</h2><blockquote>
<p>PV操作是低级通信方式，它是基于数据结构的共享；<br>高级通信方式是指以较高效率传输大量数据的通信方式，它是基于存储区的共享。</p>
</blockquote>
<p><strong>方式1：共享存储</strong></p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/5.png" class="" title="This is 5-th image.">
<p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具（如P操作、V操作），数据交换则由用户自己安排读写指令完成。</p>
<p><strong>方式2：消息传递</strong></p>
<p>消息传递系统中，进程间数据交换是以<strong>格式化消息</strong>为单位的。交换的操作需要借助系统提供的发送消息和接收消息两个原语。</p>
<p>直接通信方式：发送进程直接发送给接收进程，并将它挂在接收线程的消息缓冲队列中，没有中间实体。</p>
<p>间接通信方式：发送进程把消息发送到某个中间实体（信箱）中，接收进程从中间实体中获取消息。</p>
<p><strong>方式3：管道通信</strong></p>
<p>管道应提供三种协调能力：互斥、同步、确定对方存在。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/6.png" class="" title="This is 6-th image.">
<p><strong>管道是什么：</strong><br>  管道是用于连接一个读进程和一个写进程，以实现他们之间通信的一个<strong>共享文件</strong>（pipe文件）。</p>
<p><strong>管道特性：</strong></p>
<ul>
<li>管道只能是半双工通信，即某一个时刻只能单向传输。要实现父子进程互动通信，需要定义两个管道。</li>
<li>管道中的数据是一次性的，一旦读取就会被丢弃。</li>
<li>写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。</li>
<li>管道的大小是固定的，为4KB。</li>
<li>当缓冲区变满时，调用管道的write()的进程会被阻塞；当缓冲区为空时，调用管道的read()的进程会被阻塞。</li>
</ul>
<h2 id="6-线程的概念和多线程模型"><a href="#6-线程的概念和多线程模型" class="headerlink" title="6.线程的概念和多线程模型"></a>6.线程的概念和多线程模型</h2><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>关于线程：</p>
<ul>
<li>线程包含CPU现场，可以独立执行程序</li>
<li>每个线程没有自己的独立地址空间</li>
<li>同进程之间的线程的通信除了可以通过系统调用函数，还可以通过共享的存储空间通信。</li>
<li>引入线程后，进程仍然是<strong>资源分配</strong>的单位。线程是处理器<strong>调度和分配</strong>的单位，线程本身不拥有资源，它共享所属进程的<strong>全部资源</strong>。</li>
<li>多个用户线程映射到同一个内核线程，这多个用户线程之间的切换不需要在内核级切换进程，因此也不需要内核支持。</li>
<li>在多对一的线程模型中，用户级线程的”多“<strong>对操作系统透明</strong>，即操作系统并不知道用户有多少线程。故该进程的一个线程被阻塞后，该进程就被阻塞了，进程的其他线程当然也都被阻塞了。</li>
</ul>
<p>关于进程：</p>
<ul>
<li>在单处理器系统中，任何时刻都只有一个进程处于运行状态。错误。原因是：有可能系统发生死锁，所有进程都处于阻塞状态，或无进程任务，CPU空闲。</li>
<li>进程申请处理器而得不到满足时，其状态变为阻塞状态。错误。原因是：进程申请处理器得不到满足时就处于就绪状态，等待处理器的调度。</li>
<li>在单处理器系统中，如果同时存在10个进程，则处于就绪队列中的进程最多有<strong>9个</strong>，另一个处于运行状态。最少有0个，即发生死锁的情况，所有进程都是阻塞状态。</li>
<li>一个进程是程序在一个数据集上的一次运行过程。运行于不同的数据集，将会形成不同的进程。</li>
<li>系统动态DDL库中的系统线程，被不同的进程锁调用，它们相同的线程。原因是：<strong>同一个系统的进程（或线程）可以有系统调用的方法，被不同的进程（或线程）多次使用。</strong></li>
<li>进程从运行状态到阻塞状态是主动行为。</li>
<li>设备分配是通过在系统中设置相应的数据结构实现的，不需要创建进程，这是操作系统中IO核心子系统的内容。</li>
<li>进程间的通信主要有管道、消息传递、共享内存、文件映射、套接字等。数据库不能用于进程间的通信。</li>
</ul>
<p>C语言的内存结构：</p>
<ul>
<li>正文段（代码和赋值数据段）：存放二进制代码和常量。如全局赋值变量</li>
<li>数据堆段：存放动态分配的变量。</li>
<li>数据栈段：存放临时使用的变量。如未赋值的局部变量和实参传递</li>
</ul>
<p>进程的封闭性：</p>
<ul>
<li>并发进程的封闭性是指：进程执行的结果只取决于进程本身，不受外界影响。即不管进程是不停顿的执行还是走走停停，进程的执行速度不会改变它的执行结构。</li>
<li>并发进程失去封闭性是指：并发进程在不同的速度下执行结果不同。</li>
</ul>
<p>多道处理系统：</p>
<ul>
<li>在一个多道系统中，若就绪队列不空，就绪的进程数目越多，处理器的效率不变。</li>
</ul>
<p>为什么进程间的通信必须借助操作系统的内核功能？简要说明通信的几种主要方式。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/61.png" class="" title="This is 61-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/62.png" class="" title="This is 62-th image.">
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>作业调度是；中级调度是将作业从内存调到外存。</p>
<h1 id="1-调度层次"><a href="#1-调度层次" class="headerlink" title="1.调度层次"></a>1.调度层次</h1><ul>
<li>作业调度：将作业调度至内存，并建立相应的进程，使它们获得竞争处理机的权利。每个作业只调入一次，调出一次。</li>
<li>中级调度：又成为内存调度。<strong>为了提高内存利用率和系统吞吐量</strong>。对于那些暂时不能运行的进程，调至外存等待，此时进程状态称为挂起状态。等外存上那些具备运行条件的就绪进程再重新调入内存，并放入就绪队列中。 \</li>
<li>进程调度：又成为低级调度。主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ul>
<h1 id="2-三级调度的关系"><a href="#2-三级调度的关系" class="headerlink" title="2.三级调度的关系"></a>2.三级调度的关系</h1><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/7.png" class="" title="This is 7-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/8.png" class="" title="This is 8-th image.">
<h1 id="3-调度的时机、切换与过程"><a href="#3-调度的时机、切换与过程" class="headerlink" title="3.调度的时机、切换与过程"></a>3.调度的时机、切换与过程</h1><p>现代操作系统中，不能进行进程的调度和切换的情况：</p>
<ul>
<li>在处理中断的过程中的进程不能被切换。</li>
<li>在操作系统内核程序临界区中的进程不能被切换。进入临界区后，需要独占式地访问共享数据(加锁)，不应切换到其他进程，一方面保证资源独占，不出错，另一方面，加快该共享数据的释放。</li>
</ul>
<p>应该进行进程调度和切换的情况：</p>
<ul>
<li>当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度和切换。（非剥夺调度）</li>
<li>当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。（剥夺调度）</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/9.png" class="" title="This is 9-th image.">
<h1 id="4-进程的调度方式"><a href="#4-进程的调度方式" class="headerlink" title="4.进程的调度方式"></a>4.进程的调度方式</h1><ul>
<li>非剥夺调度方式（非抢占方式）：获得CPU的进程会保持CPU直到终止或转换到等待状态。好处是实现简单、系统开销小，适用于大多数的批处理系统，但不能用于分时系统和大多数实时系统。</li>
<li>剥夺调度方式（抢占方式）：获取CPU的进程会让出CPU给更重要或紧迫的的进程。</li>
</ul>
<p>抢占式对提高系统吞吐率和响应效率有明显好处。抢占的原则：优先权、短进程有限、时间片原则。</p>
<h1 id="5-调度的基本原则"><a href="#5-调度的基本原则" class="headerlink" title="5.调度的基本原则"></a>5.调度的基本原则</h1><ul>
<li>CPU利用率</li>
<li>系统吞吐量：即单位时间内CPU完成作业的数量。</li>
<li>周转时间：</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/10.png" class="" title="This is 10-th image.">
<ul>
<li>等待时间：指的是作业在就绪队列中等待所花的时间。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间。</li>
<li>响应时间：用户提交请求到系统首次产生响应所用的时间。</li>
</ul>
<h1 id="6-典型的调度算法"><a href="#6-典型的调度算法" class="headerlink" title="6.典型的调度算法"></a>6.典型的调度算法</h1><ul>
<li>先来先服务（FCFS）调度算法（适用于作业调度、进程调度；不可剥夺算法）<br>通过维护一个就绪队列来实现FCFS。<br>特点：<ul>
<li>长作业会让后面的短作业产生饥饿，因此它不能作为分时系统和实时系统的主要调度策略；</li>
<li>对长作业有利、对短作业不利；</li>
<li>有利于CPU繁忙型作业，不利于IO繁忙型作业</li>
<li>算法简单，效率低</li>
</ul>
</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/11.png" class="" title="This is 11-th image.">
<ul>
<li><p>短作业优先（SJF）调度算法（适用于短作业和进程的优先调度）<br>SJF指的是从后备队列中选择一个或若干个估计运行时间最短的作业或进程，将他们调入内存。</p>
<p>缺点：</p>
<ul>
<li>对长作业不利、长作业的周转时间会增加，导致长作业产生饥饿。</li>
<li>不能保证紧迫性作业会被及时处理</li>
<li>作业长短是根据用户所提供的估计执行时间而定，这个时间可能估计的不准确，使得该算法不一定能真正做到短作业优先调度。</li>
</ul>
<p>优点：</p>
<ul>
<li>平均等待时间、平均周转时间最少。</li>
</ul>
</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/12.png" class="" title="This is 12-th image.">
<ul>
<li><p>优先级调度算法（作业调度、进程调度）<br>分类：</p>
<p>按照高优先级进程能否抢占正在执行的进程：</p>
<ul>
<li>非剥夺式优先级调度算法</li>
<li>剥夺式优先级调度算法</li>
</ul>
<p>按照进程创建后其优先级是否可以改变：</p>
<ul>
<li>静态优先级</li>
<li>动态优先级：根据进程占有CPU时间的长短、就绪进程等待CPU时间的长短动态确定进程的优先级。</li>
</ul>
</li>
</ul>
<ul>
<li>高响应比优先调度算法（作业调度）<br>对FCFS和SJF的一种综合平衡，同时考虑每个作业的等待时间和估计运行时间。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/13.png" class="" title="This is 13-th image.">
<ul>
<li>时间片轮转调度算法<br>用于分时系统。就绪进程按照先后次序排成一个队列，每个出队进程占用一个时间片，用完之后，重新进入队列排队。<br>时间片根据系统的响应时间、就绪队列中的进程数目和系统的处理能力来确定。时间片太长导致所有进程都能在一个时间片内执行完毕，该算法就退化位FCFS算法；时间片太小，进程之间的切换将会很频繁，使处理机开销增大，真正用于运行用户进程的时间减少。<br>时间片的大小可以略大于一次典型的交互所需的时间，这样可以使大多数进程在一个时间片内完成。</li>
</ul>
<ul>
<li><p>多级反馈队列调度算法（集合了时间片轮转、优先级调度算法的优点）</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/14.png" class="" title="This is 14-th image.">
<ul>
<li>在一个时间片中不能完成的进程会被挪到下一级队列中，直到能够在一个时间片内完成。</li>
<li>最后一级队列采用时间片轮转的方式运行。</li>
<li>仅当第1～（i-1）级队列均为空时，才会调度第i级队列中的进程运行。当有新进程进入更高级队列中时会抢占正在运行的进程。即调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级（第1～(i-1)）的进程。</li>
</ul>
<p>优点：</p>
</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/15.png" class="" title="This is 15-th image.">
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/16.png" class="" title="This is 16-th image.">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l294265421/article/details/46450125">参考1</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lightmare/p/10398871.html">参考2</a></p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="1-进程同步的基本概念"><a href="#1-进程同步的基本概念" class="headerlink" title="1.进程同步的基本概念"></a>1.进程同步的基本概念</h2><p><strong>临界资源</strong><br>一次只允许一个进程使用的资源成为临界资源。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/17.png" class="" title="This is 17-th image.">
<p><strong>同步机制遵循的规则</strong></p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/18.png" class="" title="This is 18-th image.">
<h2 id="2-实现临界区互斥的基本方法"><a href="#2-实现临界区互斥的基本方法" class="headerlink" title="2.实现临界区互斥的基本方法"></a>2.实现临界区互斥的基本方法</h2><p><strong>1.软件实现方法</strong></p>
<ul>
<li>单标志法<br>公用整型变量turn表示允许进入临界区的进程编号。如turn=0表示允许P0进程进入临界区。该算法可保证每次只允许一个进程进入临界区。当某个进程不再进入临界区了，那么另一个进程也将无法进入临界区，违背了<strong>空闲让进</strong>。这种情况只能适合进程<strong>交替执行</strong>的情况。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/19.png" class="" title="This is 19-th image.">
<ul>
<li>双标志法先检查<br>先检查是否被其他线程正在访问，若正被访问，则等待。否则，才进入自己的临界区。<br><code>flag[i]=false</code>表示Pi进程未进入临界区。<br><code>flag[i]=true</code>表示Pi进程计入临界区。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20.png" class="" title="This is 20-th image.">
<p>  优点：不用交替进入，可连续使用；<br>  缺点：Pi与Pj可能同事进入临界区；违背“忙则等待”。如按照①②③④的顺序进入时。</p>
<ul>
<li>双标志法后检查</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/21.png" class="" title="This is 21-th image.">
<p>  问题是：会产生死锁。</p>
<ul>
<li>Peterson’s Algorithm<br>本算法是第一个算法和第三个算法的结合。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/22.png" class="" title="This is 22-th image.">
<p>对于<code>flag[i]=true; turn=j; flag[j]=true; turn=i;</code>，假设给他编号为1,2,3,4，则其可能的执行序列为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, 3, 2, 4]</span><br><span class="line">[1, 3, 4, 2]</span><br><span class="line">[3, 1, 2, 4]</span><br><span class="line">[3, 1, 4, 2]</span><br><span class="line">[3, 4, 1, 2]</span><br></pre></td></tr></table></figure><br>思考这些排列方式是否会引发线程安全问题即可。</p>
<p><strong>2.硬件实现方法</strong></p>
<ul>
<li>中断屏蔽方法<br>使用关中断会防止进程切换，这样进入临界区的进程就能顺利执行完，然后开中断。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/23.png" class="" title="This is 23-th image.">
<p>  缺点：</p>
<ul>
<li>限制了处理机交替执行程序的能力，因此执行效率会明显降低。</li>
<li>内核执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权利交给用户，当该线程关中断后，不再开中断，则系统可能会因此终止。(系统不安全)</li>
</ul>
<ul>
<li>硬件指令方法<br><code>TestAndSet指令</code>：该指令是原子操作，功能是读出指定标志后把该标志设置为真。其功能描述如下：</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/24.png" class="" title="This is 24-th image.">
<p>  实现临界区互斥访问的方法是：给每个临界资源设置一个共享不二变量lock，lock=true表示正被占用，初值为false。其算法描述为：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/25.png" class="" title="This is 25-th image.">
<p>  <code>Swap指令</code>：功能是交换两个字(字节)的内容。功能描述如下：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/26.png" class="" title="This is 26-th image.">
<p>  每个临界资源设置一个共享布尔变量lock，初始值为false，表示临界资源没有被其他进程访问。有进程在临界区时，重复交换和煎炒过程，直到进程退出。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/27.png" class="" title="This is 27-th image.">
<blockquote>
<p>TestAndSet与Swap指令并非软件实现，事实上他们是由硬件逻辑直接实现的，不会被中断。<br>硬件方法的优点：</p>
<ul>
<li>适用于任意数目的进程，不管是的单处理机还是多处理机；</li>
<li>简单、容易验证其正确性；</li>
<li>可支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。<br>硬件方法的缺点：</li>
<li>进程等待进入临界区时要耗费处理机的时间，不能实现让全等待。</li>
<li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</li>
</ul>
</blockquote>
<h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h2><ul>
<li>整型信号量<br>整型信号量被定义为一个用于表示资源数目的整型量S。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/28.png" class="" title="This is 28-th image.">
<p>  缺点是不能遵循“让权等待”。</p>
<ul>
<li>记录型信号量<br>不存在“忙等”现象。value表示资源数目，进程链表L表示所有等待该资源的进程。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/29.png" class="" title="This is 29-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/30.png" class="" title="This is 30-th image.">
<p><strong>1.利用信号量实现进程同步</strong></p>
<p>只有当语句x执行完成后，语句y才能执行：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/31.png" class="" title="This is 31-th image.">
<p><strong>2.利用信号量实现进程互斥</strong></p>
<p>假设S为实现P1，P2互斥的信号量，由于每次只允许一个进程进入临界区，所以S的初值应为1。只需要把临界区置于P(S)与V(S)之间即可实现两进程的互斥访问。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/32.png" class="" title="This is 32-th image.">
<p><strong>3.利用信号量实现前驱关系</strong></p>
<p>为保证S1→S2，S1→S3的前驱关系，应分别设置信号量a1，a2.为了保证S2→S4，S2→S5，S3→S6，S4→S6，S5→S6，应设置信号量b1，b2，c，d，e。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/33.png" class="" title="This is 33-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/34.png" class="" title="This is 34-th image.">
<h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4.管程"></a>4.管程</h2><p>管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化病改变管程中的数据和同步进程。</p>
<p>管程的组成：</p>
<ul>
<li>局部于管程的共享结构数据说明。</li>
<li>对该数据结构进行操作的一组过程。</li>
<li>对局部于管程的共享数据设置初始值的语句。</li>
</ul>
<p>管程的基本特性：</p>
<ul>
<li>局部于管程中的数据只能被局部于管程内的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据。</li>
<li>每次仅允许一个进程在管程内执行某个内部过程。</li>
</ul>
<p>管程是语言的一部分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注。</p>
<h2 id="5-经典同步问题"><a href="#5-经典同步问题" class="headerlink" title="5.经典同步问题"></a>5.经典同步问题</h2><h3 id="5-1-生产者-消费者问题"><a href="#5-1-生产者-消费者问题" class="headerlink" title="5.1 生产者-消费者问题"></a>5.1 生产者-消费者问题</h3><p><strong>问题描述：</strong>一组生产者进程与一组消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p>
<ul>
<li>关系分析：生产者与消费者对缓冲区是互斥关系；生产者与消费者是一个协作关系，只有生产者生产后，消费者才能消费，他们也是同步关系。</li>
<li>信号量设置：mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥限号两初值为1；信号量full表示当前缓冲池中“满”的缓冲区数，初值为0；信号量empty表示缓冲池中“空”的缓冲区数，初值为n。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/35.png" class="" title="This is 35-th image.">
<p><strong>注意：</strong></p>
<ul>
<li>生产者先执行P(mutex)然后执行P(empty)，消费者先执行P(mutex)然后执行P(full)，在生产者获得互斥量mutex后，发现并没有空的缓冲区(empty为0)，这时候就会产生死锁，即生产者线程等待缓冲区释放，却保持着对线程池的访问，而消费者则无法获取到缓冲池的访问权，更无法释放缓冲区，便发生了死锁。</li>
</ul>
<h3 id="5-2-复杂生产者-消费者问题"><a href="#5-2-复杂生产者-消费者问题" class="headerlink" title="5.2 复杂生产者-消费者问题"></a>5.2 复杂生产者-消费者问题</h3><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/36.png" class="" title="This is 36-th image.">
<ul>
<li>关系分析：爸爸和妈妈是互斥关系，爸爸和女儿、妈妈和儿子是同步关系，儿子和女儿没有互斥和同步关系。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/37.png" class="" title="This is 37-th image.">
<ul>
<li>信号量设置：<code>plate</code>为互斥信号量，表示是否允许向盘子放入水果，初值为1(允许放入)；<code>apple</code>表示盘子中是否有苹果，初值为0(表示盘子为空)；<code>orgnge</code>表示盘子中是否有橘子，初值为0(表示盘子为空)。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/38.png" class="" title="This is 38-th image.">
<p>女儿拿走苹果后，或儿子拿走橘子后才能释放盘子，即V(plate)。</p>
<h3 id="5-3-读者-写者问题"><a href="#5-3-读者-写者问题" class="headerlink" title="5.3 读者-写者问题"></a>5.3 读者-写者问题</h3><ul>
<li>关系分析：读者与写者是互斥的、写者与写者互斥，读者与读者不存在互斥问题。</li>
<li>信号量设置：count计数器用来记录当前读者数量，初值为0；互斥信号量mutex为保护更新count变量时的互斥；互斥信号量rw用于保证读者和写者的互斥访问。</li>
</ul>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/39.png" class="" title="This is 39-th image.">
<p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。<br>实现方法是：在write()、reader()中各加入一对PV操作，即互斥信号量w表示有无写进程进行。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/40.png" class="" title="This is 40-th image.">
<p>上述算法并不是真正意义上的写优先，而是读写是一样的优先级。当一个写进程访问文件时，如果<strong>先有</strong>一些读进程要求访问文件，而<strong>再有</strong>另一个写进程要求访问文件，那么当当前访问文件的进程结束对文件的写操作时，会是一个读进程占用文件而不是写进程（在信号量w的阻塞队列上，因为读进程先来，而排在阻塞队列队首，而V操作唤醒进程时唤醒的是队首进程），所以这里的写优先是相对的。</p>
<blockquote>
<p>技巧：互斥访问计数器count</p>
</blockquote>
<h3 id="5-4-哲学家进餐问题"><a href="#5-4-哲学家进餐问题" class="headerlink" title="5.4 哲学家进餐问题"></a>5.4 哲学家进餐问题</h3><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/41.png" class="" title="This is 41-th image.">
<p>关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。<br>解决方式1：只有当一个哲学家左右两边的筷子都可用时，才允许抓起筷子。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/42.png" class="" title="This is 42-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/43.png" class="" title="This is 43-th image.">
<h3 id="5-5-吸烟者问题"><a href="#5-5-吸烟者问题" class="headerlink" title="5.5 吸烟者问题"></a>5.5 吸烟者问题</h3><p>一个供应者三个抽烟者，供应者提供烟草、纸、胶水三种中的其中两种，抽烟者需要三种材料才能完成抽烟，且桌上只能同时放两种材料。完成三个抽烟者轮流抽烟的动作。</p>
<p>关系分析：供应者与三个抽烟者分别是同步关系；三个抽烟者对抽烟这个动作互斥（或有三个抽烟者轮流抽烟得知）<br>信号量设置：信号量offer1，offer2，offer3表示烟草和纸的资源组合、烟草和胶水的资源组合、纸和胶水的资源组合。</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/44.png" class="" title="This is 44-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/45.png" class="" title="This is 45-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/46.png" class="" title="This is 46-th image.">
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="1-死锁处理策略"><a href="#1-死锁处理策略" class="headerlink" title="1.死锁处理策略"></a>1.死锁处理策略</h2><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/47.png" class="" title="This is 47-th image.">
<h2 id="2-死锁预防"><a href="#2-死锁预防" class="headerlink" title="2.死锁预防"></a>2.死锁预防</h2><ul>
<li>破坏互斥条件<br>可行性小。有的场合需要保护这种互斥性。</li>
<li>破坏不剥夺条件<br>当请求新的资源得不到满足时，必须释放已经保持的资源。<br>缺点是：实现复杂，释放已获得的资源可能造成前一阶段工作的失效，反复申请和释放资源会增加系统开销，降低系统吞吐量。<br>优点是：对于状态易于保存和恢复的资源，如CPU的寄存器和内存资源。一般不能用于打印机之类的资源。</li>
<li>破坏请求与保持条件<br>预先分配进程执行前需要的全部资源。<br>缺点是：系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不适用；还会导致饥饿现象，当由于个别资源长期被其他进程占用时，将导致等待该资源的进程吃吃不能运行。</li>
<li>破坏循环等待条件<br>采用顺序资源分配的方法，即给系统中的资源编号，让每个进程按照顺序获取所需要的资源。<br>缺点是：编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源浪费；按照次序申请资源，给编程带来麻烦。</li>
</ul>
<h2 id="3-银行家算法"><a href="#3-银行家算法" class="headerlink" title="3.银行家算法"></a>3.银行家算法</h2><p><strong>可利用资源矢量Available</strong>：<code>Available[j]=K</code>表示系统中先有Rj类资源K个。<br><strong>最大需求矩阵Max</strong>：<code>Max[i][j]=K</code>表示进程i需要Rj类资源的最大数目为K。<br><strong>分配矩阵Allocation</strong>：<code>Allocaltion[i][j]=K</code>表示进程i当前已经分得Rj类思源的数目为K。<br><strong>需求矩阵Need</strong>：<code>Need[i][j]=K</code>表示进程i还需要Rj类资源的数目为K。</p>
<p>上述矩阵满足<code>Need=Max-Allocation</code></p>
<p>算法描述：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/48.png" class="" title="This is 48-th image.">
<p>安全性算法（构造安全序列）：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/49.png" class="" title="This is 49-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/50.png" class="" title="This is 50-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/51.png" class="" title="This is 51-th image.">
<h1 id="4-死锁的检测和解除"><a href="#4-死锁的检测和解除" class="headerlink" title="4.死锁的检测和解除"></a>4.死锁的检测和解除</h1><h2 id="4-1-资源分配图"><a href="#4-1-资源分配图" class="headerlink" title="4.1 资源分配图"></a>4.1 资源分配图</h2><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/52.png" class="" title="This is 52-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/53.png" class="" title="This is 53-th image.">
<p>对于进程来说，入度表示已经获取的资源，出度表示需要请求的资源。</p>
<h2 id="4-2-死锁定理（用于检测系统状态S是否为死锁状态）"><a href="#4-2-死锁定理（用于检测系统状态S是否为死锁状态）" class="headerlink" title="4.2 死锁定理（用于检测系统状态S是否为死锁状态）"></a>4.2 死锁定理（用于检测系统状态S是否为死锁状态）</h2><p>资源分配图状态简化：</p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/54.png" class="" title="This is 54-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/55.png" class="" title="This is 55-th image.">
<h2 id="4-3-死锁解除"><a href="#4-3-死锁解除" class="headerlink" title="4.3 死锁解除"></a>4.3 死锁解除</h2><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/56.png" class="" title="This is 56-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/57.png" class="" title="This is 57-th image.">
<h1 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h1><img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/58.png" class="" title="This is 58-th image.">
<p><strong>作业和进程的关系：</strong></p>
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/59.png" class="" title="This is 59-th image.">
<img src="/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/60.png" class="" title="This is 60-th image.">
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS">YFS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">http://jeckfs.gitee.io/JeckFS/2020/09/19/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeckfs.gitee.io/JeckFS" target="_blank">JeckFS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/JeckFS/tags/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">王道操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=2322041376,2548191196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JeckFS/2020/09/30/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><img class="prev-cover" src="https://img2.baidu.com/it/u=2566230917,2808117782&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">三、内存管理</div></div></a></div><div class="next-post pull-right"><a href="/JeckFS/2020/09/19/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src="https://img1.baidu.com/it/u=2709423071,2700494803&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=500&amp;h=281" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一、操作系统概述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JeckFS/2020/10/20/Temp/" title="Temp"><img class="cover" src="https://img0.baidu.com/it/u=3798217922,3880088897&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Temp</div></div></a></div><div><a href="/JeckFS/2020/09/30/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="三、内存管理"><img class="cover" src="https://img2.baidu.com/it/u=2566230917,2808117782&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-30</div><div class="title">三、内存管理</div></div></a></div><div><a href="/JeckFS/2020/09/19/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="一、操作系统概述"><img class="cover" src="https://img1.baidu.com/it/u=2709423071,2700494803&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=281" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-19</div><div class="title">一、操作系统概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/JeckFS/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YFS</div><div class="author-info__description">快乐每一天</div></div><div class="card-info-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">248</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text">1.进程的概念与特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">2.进程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">3.进程的控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">1.4.</span> <span class="toc-text">4.进程的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.5.</span> <span class="toc-text">5.进程的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">6.线程的概念和多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">处理机调度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="toc-number">3.</span> <span class="toc-text">1.调度层次</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">2.三级调度的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">3.调度的时机、切换与过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">4.进程的调度方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">7.</span> <span class="toc-text">5.调度的基本原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">6.典型的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">9.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">1.进程同步的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">2.实现临界区互斥的基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.3.</span> <span class="toc-text">3.信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%A1%E7%A8%8B"><span class="toc-number">9.4.</span> <span class="toc-text">4.管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.</span> <span class="toc-text">5.经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.1.</span> <span class="toc-text">5.1 生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A4%8D%E6%9D%82%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.2.</span> <span class="toc-text">5.2 复杂生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.3.</span> <span class="toc-text">5.3 读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.4.</span> <span class="toc-text">5.4 哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.5.</span> <span class="toc-text">5.5 吸烟者问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">10.1.</span> <span class="toc-text">1.死锁处理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">10.2.</span> <span class="toc-text">2.死锁预防</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">3.银行家算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">11.</span> <span class="toc-text">4.死锁的检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">11.1.</span> <span class="toc-text">4.1 资源分配图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86%EF%BC%88%E7%94%A8%E4%BA%8E%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81S%E6%98%AF%E5%90%A6%E4%B8%BA%E6%AD%BB%E9%94%81%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">4.2 死锁定理（用于检测系统状态S是否为死锁状态）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="toc-number">11.3.</span> <span class="toc-text">4.3 死锁解除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">12.</span> <span class="toc-text">总结：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧"><img src="https://img0.baidu.com/it/u=297071526,3870034878&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=499&amp;h=332" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="vim-使用技巧"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧">vim-使用技巧</a><time datetime="2022-12-23T04:09:28.000Z" title="发表于 2022-12-23 12:09:28">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点"><img src="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="NAS-SAN异同点"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点">NAS-SAN异同点</a><time datetime="2022-12-12T02:06:26.000Z" title="发表于 2022-12-12 10:06:26">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC"><img src="https://img1.baidu.com/it/u=2231100910,1753720113&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-高级IPC"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC">Unix-高级IPC</a><time datetime="2022-12-10T03:55:57.000Z" title="发表于 2022-12-10 11:55:57">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets"><img src="https://img2.baidu.com/it/u=208782341,2933630295&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=641&amp;h=361" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-网络IPC-Sockets"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets">Unix-网络IPC-Sockets</a><time datetime="2022-12-07T05:37:59.000Z" title="发表于 2022-12-07 13:37:59">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" title="Unix-进程通讯"><img src="https://img2.baidu.com/it/u=2566230917,2808117782&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-进程通讯"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" title="Unix-进程通讯">Unix-进程通讯</a><time datetime="2022-12-03T11:33:28.000Z" title="发表于 2022-12-03 19:33:28">2022-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YFS</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/JeckFS/js/utils.js"></script><script src="/JeckFS/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/JeckFS/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>