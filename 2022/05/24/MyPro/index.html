<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MyPro | JeckFS</title><meta name="keywords" content="项目"><meta name="author" content="YFS"><meta name="copyright" content="YFS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Spring 解决循环依赖参考教程 出现循环依赖的前提条件：  Bean 是单例的 相互依赖的 Bean 都是使用构造器注入的方式  Spring 能够解决的循环依赖类型：  Spring 解决循环依赖时的调用图：  黑色为调用走向，绿色为递归返回走向。  Spring 是通过递归的方式获取目标 bean 及其所依赖的 bean 的； Spring 实例化一个 bean 的时候，是分两步进行">
<meta property="og:type" content="article">
<meta property="og:title" content="MyPro">
<meta property="og:url" content="http://jeckfs.gitee.io/JeckFS/2022/05/24/MyPro/index.html">
<meta property="og:site_name" content="JeckFS">
<meta property="og:description" content="1. Spring 解决循环依赖参考教程 出现循环依赖的前提条件：  Bean 是单例的 相互依赖的 Bean 都是使用构造器注入的方式  Spring 能够解决的循环依赖类型：  Spring 解决循环依赖时的调用图：  黑色为调用走向，绿色为递归返回走向。  Spring 是通过递归的方式获取目标 bean 及其所依赖的 bean 的； Spring 实例化一个 bean 的时候，是分两步进行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.baidu.com/it/u=2231100910,1753720113&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2022-05-24T11:22:06.000Z">
<meta property="article:modified_time" content="2022-06-16T07:09:08.926Z">
<meta property="article:author" content="YFS">
<meta property="article:tag" content="项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img1.baidu.com/it/u=2231100910,1753720113&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/JeckFS/img/favicon.png"><link rel="canonical" href="http://jeckfs.gitee.io/JeckFS/2022/05/24/MyPro/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/JeckFS/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/JeckFS/',
  algolia: undefined,
  localSearch: {"path":"/JeckFS/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MyPro',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-16 15:09:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">234</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">63</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img1.baidu.com/it/u=2231100910,1753720113&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/JeckFS/">JeckFS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MyPro</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-24T11:22:06.000Z" title="发表于 2022-05-24 19:22:06">2022-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-16T07:09:08.926Z" title="更新于 2022-06-16 15:09:08">2022-06-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MyPro"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Spring-解决循环依赖"><a href="#1-Spring-解决循环依赖" class="headerlink" title="1. Spring 解决循环依赖"></a>1. Spring 解决循环依赖</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A_Java_Dog/article/details/117192587#:~:text=答：Spring,tories）%E3%80%82">参考教程</a></p>
<p>出现循环依赖的前提条件：</p>
<ul>
<li>Bean 是单例的</li>
<li>相互依赖的 Bean 都是使用构造器注入的方式</li>
</ul>
<p>Spring 能够解决的循环依赖类型：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-24_19-28-13.png" class="" title="This is 1-th image.">
<p>Spring 解决循环依赖时的调用图：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-24_19-32-04.png" class="" title="This is 1-th image.">
<p>黑色为调用走向，绿色为递归返回走向。</p>
<ul>
<li>Spring 是通过递归的方式获取目标 bean 及其所依赖的 bean 的；</li>
<li>Spring 实例化一个 bean 的时候，是分两步进行的，首先实例化目标 bean ，然后为其注入属性。</li>
</ul>
<p>Spring 中的 “三级缓存”：</p>
<ul>
<li><code>singletonObjects</code>:一级缓存 存储的是所有创建好了的单例Bean</li>
<li><code>earlySingletonObjects</code> ：完成实例化，但是还未进行属性注入及初始化的对象</li>
<li><code>singletonFactories</code> : 提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</li>
</ul>
<p>A 依赖于 B ， B 依赖于 A 的循环依赖解决（没有 AOP 增强的循环依赖）：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-24_19-42-01.png" class="" title="This is 1-th image.">
<p>带 AOP 的循环依赖：<br>带AOP的跟不带AOP的其实几乎一样，只是在三级缓存中存放的是<strong>函数式接口</strong>，在需要调用时直接<strong>返回代理对象</strong>。<br>三级缓存存在的意义：</p>
<ul>
<li>只有真正发生循环依赖的时候，才去提前生成代理对象；</li>
<li>对于没有发生循环依赖时，只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象；</li>
</ul>
<p>带 AOP 的循环依赖与不带AOP 的区别是：通过三级缓存的函数式接口获取对象 A 时，是实例化后的对象 A 还是代理对象 A 。</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-24_20-07-42.png" class="" title="This is 1-th image.">
<p><strong>getBean(A) 时先实例化对象 A 然后将 A 的函数式接口放入三级缓存中，通过调用函数式接口得到代理对象 A。然后为~代理~对象 A 属性注入，在注入依赖对象 B 时，B 中的依赖对象 A 是从三级缓存中获取到的代理对象 A，这时 B 对象可以顺利完成初始化，A 也可以顺利完成初始化。</strong><br>重点是 A 实例化后会将用于创建代理对象 A 的函数式接口放入三级缓存中，在 B 对象进行属性注入时，是从三级缓存中获取到 A 的代理对象。<br>当对象 B 完成属性注入后，考虑到 A 是单例的原因，会将三级缓存的代理工厂删除，并将代理<code>?</code>对象 A 放入二级缓存中，等属性注入完成并初始化（执行 Aware 接口中的方法、初始化方法，完成 AOP 代理）成功后，会放入一级缓存。</p>
<p>为什么必须用三级缓存：<br>考虑到 AOP 的特性，必须以代理对象的方式实现增强。使用三级缓存时，A 对象的创建会放入三级缓存中。在 B 对象初始化完成后，就可以注入对象 A 的所有属性。这也就符合 Spring 的设计原则：对初始化后的 Bean 进行 AOP 代理；如果不使用三级缓存，就需要直接创建 A 的代理对象，这样对象 A 无法完成初始化就要进行 AOP 代理，违背 Spring 设计原则。</p>
<h1 id="2-Apollo"><a href="#2-Apollo" class="headerlink" title="2. Apollo"></a>2. Apollo</h1><h2 id="2-1-特性"><a href="#2-1-特性" class="headerlink" title="2.1 特性"></a>2.1 特性</h2><ul>
<li>支持不同环境（env），不同集群（cluster），不同命名空间（namespaces）的配置</li>
<li>支持热发布</li>
<li>支持配置回滚</li>
<li>支持灰度发布，可以对部分实例生效，没问题了再推广到全部的实例</li>
<li>支持配置信息监控（哪些实例在使用）</li>
<li>除了 Portal 管理配置，也可以通过程序管理自己的配置（需在 Portal 中授权获取 Token）。支持 Java 、 Shell 、 .Net core 三种方式管理配置</li>
<li>支持 Skywalking </li>
<li>支持 prometheus</li>
<li>支持 Docker 部署，分布式部署</li>
</ul>
<h2 id="2-2-相关配置"><a href="#2-2-相关配置" class="headerlink" title="2.2 相关配置"></a>2.2 相关配置</h2><p>必选配置：</p>
<ul>
<li><code>appId</code> : 表示应用的唯一身份</li>
<li><code>appllo.meta</code> ： 用于提供给Apollo客户端当前环境的 Apollo Meta Server 信息。</li>
<li>本地缓存路径：默认是 <code>/opt/data</code> ，缓存配置命名： <code>&#123;appId&#125;+&#123;cluster&#125;+&#123;namespace&#125;.properties</code></li>
<li>自定义缓存路径： <code>-Dapollo.cache-dir=/opt/data/some-cache-dir</code> 或者 <code>apollo.cacheDir=/opt/data/some-cache-dir</code></li>
</ul>
<p>可选配置：</p>
<ul>
<li>Environment : <code>-Denv=YOUR-ENVIRONMENT</code></li>
<li>cluster : <code>apollo.cluster=&#39;SomeCluster&#39;</code> ， 首先获取 <code>apollo.cluster</code> 指定的配置，若不存在则查找<em>数据中心</em>?的cluster，若还不存在则使用默认的集群配置（default）</li>
<li>访问密钥 ： <code>apollo.access-key.secret</code> 只有经过身份验证的客户端才能访问敏感配置</li>
<li>自定义 server.properties 路径： <code>apollo.path.server.properties</code></li>
<li>开启propertyNames缓存： <code>apollo.property.names.cache.enable</code> 通过开启该配置可以显著提升启动速度，当配置发生变化时缓存会自动清理，默认为 false</li>
<li>ApolloLabel ： <code>-Dapollo.label=YOUR-APOLLO-LABEL</code> ApolloLabel 是应用的标签信息，是从服务端获取配置的一个重要信息，用于灰度规则的配置。</li>
</ul>
<h2 id="2-3-客户端用法"><a href="#2-3-客户端用法" class="headerlink" title="2.3 客户端用法"></a>2.3 客户端用法</h2><ul>
<li>通过 API 直接使用，不依赖于 Spring 框架。通过 API 可以获取具体某个 namespaces 的配置某一项的配置、也可以监听配置的变更。</li>
<li>与 Spring 整合：<ul>
<li>支持配置到 bean xml 的配置中；</li>
<li>支持在 Java 代码中配置： <code>@Configuration @EnableApolloConfig</code></li>
<li>Springboot 集成：</li>
<li>支持 Spring PlaceHolder ： <ul>
<li>Bean XML 中： <code>$&#123;key:defaultValue&#125;</code></li>
<li><code>@Value(&quot;&#123;key:defaultValue&#125;&quot;)</code></li>
<li>通过 <code>@Configuration @EnableApolloConfig</code> 配置 Bean 的配置类， <code>@Bean</code> 修饰的方法可以直接在 new Bean() 的时候注入属性。</li>
<li><code>@ConfigurationProperties(prefix = &quot;redis.cache&quot;)</code> 将配置注入到普通对象到属性中。</li>
</ul>
</li>
<li>通过注解注入<ul>
<li><code>@ApolloConfig</code> ： 用来自动注入Config对象</li>
<li><code>@ApolloConfigChangeListener</code> ： 用来自动注册ConfigChangeListener</li>
<li><code>@ApolloJsonValue</code> ： 用来把配置的json字符串自动注入为对象</li>
<li><code>@Configuration @EnableApolloConfig</code> ： 注入 Configure 类中的 Bean 属性</li>
<li><code>@Value</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-Apollo-客户端设计原理："><a href="#2-4-Apollo-客户端设计原理：" class="headerlink" title="2.4 Apollo 客户端设计原理："></a>2.4 Apollo 客户端设计原理：</h2><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_08-16-11.png" class="" title="This is 1-th image.">
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_08-17-13.png" class="" title="This is 1-th image.">
<p>配置更新<strong>推送</strong>实现：</p>
<ul>
<li>客户端向服务端发起 HTTP 请求，并建立一个长链接（60s）</li>
<li>如果在 60s 内有配置更新，被保持住的客户端请求会立即返回，并告知客户端有变化的 namespaces ，客户端据此拉取有变更的 namespaces 。</li>
<li>如果 60s 内无配置更新，会返回 304 - Not Modified 给客户端。</li>
<li>客户端收到服务端请求后会重新发起长链接。</li>
</ul>
<h2 id="2-5-总体设计"><a href="#2-5-总体设计" class="headerlink" title="2.5 总体设计"></a>2.5 总体设计</h2><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_15-18-21.png" class="" title="This is 1-th image.">
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_15-18-47.png" class="" title="This is 1-th image.">
<h2 id="2-6-为什么-Apollo-选用-Eureka"><a href="#2-6-为什么-Apollo-选用-Eureka" class="headerlink" title="2.6 为什么 Apollo 选用 Eureka"></a>2.6 为什么 Apollo 选用 Eureka</h2><ul>
<li>为了提高配置中心的可用性和降低部署复杂度，我们需要尽可能地减少外部依赖。</li>
<li>它提供了完整的 Service Registry 和 Service Discovery 实现，并经受住了考验</li>
<li>开源，方便问题排查</li>
</ul>
<h2 id="2-7-各模块介绍"><a href="#2-7-各模块介绍" class="headerlink" title="2.7 各模块介绍"></a>2.7 各模块介绍</h2><ul>
<li>Config Service：<ul>
<li>提供配置更新推送接口（基于Http long polling）<ul>
<li>服务端使用Spring DeferredResult实现异步化，从而大大增加长连接数量</li>
<li>目前使用的tomcat embed默认配置是最多10000个连接（可以调整），使用了4C8G的虚拟机实测可以支撑10000个连接，所以满足需求（一个应用实例只会发起一个长连接）。</li>
</ul>
</li>
<li>接口服务对象为Apollo客户端</li>
</ul>
</li>
<li>Admin Service<ul>
<li>提供配置管理接口</li>
<li>提供配置修改、发布等接口</li>
<li>接口服务对象为Portal</li>
</ul>
</li>
<li>Meta server<ul>
<li>Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port）</li>
<li>Client通过域名访问Meta Server获取Config Service服务列表（IP+Port）</li>
<li>Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client</li>
<li>增设一个Meta Server的角色主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件</li>
<li>Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致</li>
</ul>
</li>
<li>Eureka<ul>
<li>基于Eureka和Spring Cloud Netflix提供服务注册和发现</li>
<li>Config Service和Admin Service会向Eureka注册服务，并保持心跳</li>
<li>为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的（通过Spring Cloud Netflix）</li>
</ul>
</li>
<li>Portal<ul>
<li>提供Web界面供用户管理配置</li>
<li>通过Meta Server获取Admin Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Portal侧做load balance、错误重试</li>
</ul>
</li>
<li>Client<ul>
<li>Apollo提供的客户端程序，为应用提供配置获取、实时更新等功能</li>
<li>通过Meta Server获取Config Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Client侧做load balance、错误重试</li>
</ul>
</li>
</ul>
<h2 id="2-8-配置发布后的实时推送设计"><a href="#2-8-配置发布后的实时推送设计" class="headerlink" title="2.8 配置发布后的实时推送设计"></a>2.8 配置发布后的实时推送设计</h2><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_16-28-15.png" class="" title="This is 1-th image.">
<p>发送ReleaseMessage的实现方式：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_16-29-20.png" class="" title="This is 1-th image.">
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_16-29-39.png" class="" title="This is 1-th image.">
<p><a target="_blank" rel="noopener" href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_212-config-service通知客户端的实现方式">Config Service通知客户端的实现方式</a>：<br><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_16-58-26.png" class="" title="This is 1-th image."></p>
<p><a target="_blank" rel="noopener" href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_31-和spring集成的原理">和 Spring 集成的原理:</a></p>
<p>Spring 中的 ApplicationContext 中会关联 ConfugurableEnvironment 对象，该对象提供了获取多个 PropertySource 的方法。而每个 PropertySource 中包含了多个 key-Value 的配置项。Spring 会顺序读取 PropertySource 中的配置（排在前面的优先级高于后面的）。 Apollo 在运行时会将配置以 PropertySource 的形式插入到 PropertySource 列表的第一个。</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-05-25_20-07-39.png" class="" title="This is 1-th image.">
<h2 id="2-9-Namespaces"><a href="#2-9-Namespaces" class="headerlink" title="2.9 Namespaces"></a>2.9 Namespaces</h2><p>Namespaces 获取权限（针对于 Apollo 客户端）分类：</p>
<ul>
<li>private （私有的，只能被所属应用获取）</li>
<li>public （公共的，所有应用都可以获取）</li>
</ul>
<p>Namespaces 的类型：</p>
<ul>
<li>私有类型（具有 private 权限）</li>
<li>公共类型（具有 public 权限）</li>
<li>继承类型（具有 private 权限，集成自公共类型的 Namespaces，用于覆盖公共配置中的某些配置）</li>
</ul>
<h1 id="3-Skywalking"><a href="#3-Skywalking" class="headerlink" title="3. Skywalking"></a>3. Skywalking</h1><p><a href="https://jeckfs.gitee.io/2021/09/04/APM-skywalking/">Skywalking 视频教程</a><br><a href="https://jeckfs.gitee.io/2021/09/15/APM-skywalking-书籍目录笔记/">Skywalking 部分笔记</a><br><a href="https://jeckfs.gitee.io/2021/09/14/skywalking-其他主机接入skywalking日志/">其他主机接入skywalking日志</a><br><a href="https://jeckfs.gitee.io/2021/07/26/链路追踪/">其他介绍</a></p>
<h1 id="4-涉及-Redis-、数据库、跨中心调用时如何尽可能保持数据一致性"><a href="#4-涉及-Redis-、数据库、跨中心调用时如何尽可能保持数据一致性" class="headerlink" title="4. 涉及 Redis 、数据库、跨中心调用时如何尽可能保持数据一致性"></a>4. 涉及 Redis 、数据库、跨中心调用时如何尽可能保持数据一致性</h1><mark class="hl-label green">业务场景：</mark>  中心 A 在做业务逻辑 a 时需要更改数据库和 redis ，中心 A 成功后需要调用中心 B 的 b 接口更改中心 B 的数据。 <br>

<mark class="hl-label green">问题：</mark>  中心 A 成功更新数据库和 redis ，但是中心 B 却写入失败的情况。<br>

<mark class="hl-label green">解决方案：</mark>  中心 A 将操作 redis 和数据库的代码放入事务中，调用中心 B 的代码放在事务之外。这样可以保证中心 A 的操作一定是成功的状态下，才会调用中心 B 去更改数据。若事务失败，则捕获异常直接清除写入 redis 中的 key ，以保证 redis 中不存在脏数据。但是有个问题是中心 B 在更改数据库或者 redis 时失败应该怎么办？当前采用的方案是： <mark class="hl-label default">当中心A事务成功后，向MQ中发送一个消息（包含了中心B更新数据的输入数据），当失败时中心B从数据库中取出数据进行重试</mark>  <br>
另一种方案是使用分布式事务 <mark class="hl-label pink">分布式事务</mark> 。<br>

<mark class="hl-label red">仍存在的问题:</mark>  
<ul>
<li>中心 A 在向 MQ 中写入消息时不一定是成功的，需要依赖于 MQ 的健壮性</li>
<li>当中心 B 的数据库或者 redis 挂掉后，中心 B 不见得能够重试成功。这时可以走人工</li>
</ul>
<p>这也是尽可能的保证数据一致性。</p>
<h1 id="5-分布式事务"><a href="#5-分布式事务" class="headerlink" title="5. 分布式事务"></a>5. 分布式事务</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">分布式事务教程</a></p>
<h2 id="5-1-2PC"><a href="#5-1-2PC" class="headerlink" title="5.1 2PC"></a>5.1 2PC</h2><p><img src="Snipaste_2022-06-10_20-20-30.png" width="70%" height="70%"></p>
<p>2PC 分两个阶段：准备阶段和提交阶段。2PC 的执行是一个 <mark class="hl-label green">同步阻塞</mark>  的执行过程， 2PC 并不能保证数据的强一致性的原因：</p>
<ul>
<li>参与者执行的状态不同。如有的参与者已经提交有的没有提交、有的已经回滚有的没有回滚、有的已经准备有的没有准备</li>
<li>2PC 是一个同步阻塞过程</li>
</ul>
<p>协调者故障分析 : </p>
<ul>
<li>假设协调者在 <mark class="hl-label pink">发送准备命令之前挂了</mark>  ，此时相当于事务没有开始</li>
<li>假设协调者在 <mark class="hl-label pink">发送准备命令之后挂了</mark>  ，此时已经执行准备命令的部分或全部参与者将会处于阻塞状态。</li>
<li>假设协调者在 <mark class="hl-label pink">发送回滚命令之前挂了</mark>  ，此时证明所有参与者都已准备好，所有的参与者都会处于阻塞状态。</li>
<li>假设协调者在 <mark class="hl-label pink">发送回滚命令之后挂了</mark>  ，此时运气好的话所有参与者都回滚，当遇到网络分区问题，会导致部分参与者收不到回滚命令而一直阻塞。</li>
<li>假设协调者在 <mark class="hl-label pink">发送提交命令之前挂了</mark>  ，此时所有参与者都处于准备状态，因此都会阻塞。</li>
<li>假设协调者在 <mark class="hl-label pink">发送提交命令之后挂了</mark>  ，此时运气好的话所有参与者都提交成功，当遇到网络分区问题，会导致部分参与者一直阻塞。</li>
</ul>
<p>协调者故障，通过选举产生新的协调者：</p>
<ul>
<li>若选举发生在第一阶段：所有协调者都处于准备阶段，通过回滚就可以解决。</li>
<li>若选举发生在第二阶段：<ul>
<li>假设所有协调者没有挂，此时协调者可以向所有参与者询问执行情况来推断下一步操作。</li>
<li>假设有部分协调者挂掉，新的协调者不知道哪个参与者挂掉了（因为新的协调者只能询问存活的参与者的状态），所以没有办法保证挂掉的协调者的数据与其他正常协调者的一致。<ul>
<li>这种问题可以通过协调者写入日志来 <mark class="hl-label pink">记录发过哪些日志</mark>  ，新协调者可以通过日志判断哪些协调者挂掉。</li>
<li>问题：当旧协调者发送提交命令后，由于网络分区原因部分协调者没有收到命令，收到命令的成功提交。这时候新协调者在面对部分或所有参与者挂掉的情况，就无法判断哪些挂掉的协调者已经提交，哪些没有提交。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>由于 2PC 的 <mark class="hl-label pink">协调者单点故障问题</mark>  因此在极端情况下 2PC 仍无法保证数据强  一致性，只是 <mark class="hl-label pink">尽量保证强一致性</mark>  。</p>
<h2 id="5-2-3PC"><a href="#5-2-3PC" class="headerlink" title="5.2 3PC"></a>5.2 3PC</h2><p>3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它 <mark class="hl-label pink">在参与者中也引入了超时机制</mark>  ，并且 <mark class="hl-label pink">新增了一个阶段</mark>  使得参与者可以利用这一个阶段统一各自的状态。<br></p>
<p>3PC ： 包含 <mark class="hl-label pink">准备阶段(CanCommit)、预提交阶段(PreCommit)和提交阶段(DoCommit)</mark>   <br></p>
<p>相对于 2PC ，3PC 将提交阶段分为了 <mark class="hl-label pink">预提交阶段和提交阶段</mark>  ，并且 3PC 协调者只是询问参与者负载是否沉重之类的。 <br></p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-11_08-58-52.png" class="" title="This is 2-th image.">
<mark class="hl-label green">3PC的特点：</mark>  <br>
* <mark class="hl-label pink">准备阶段的变更成不会直接执行事务，仅仅是询问是否有条件执行该事务，因此不会一上来就直接锁资源。</mark> 
<ul>
<li><mark class="hl-label pink">预提交阶段的引入起到了一个统一状态的作用</mark>  ，到达预提交阶段表明所有参与者都已经回应了，当前可以执行事务。对于参与者而言，当其进入到预提交状态或者提交状态，则可以肯定其他参与者也到达了预提交状态或者提交状态。</li>
<li>接上一点，当发送 <mark class="hl-label pink">提交命令（或回滚命令）之前</mark>  （此时所有参与者都已是预提交状态），协调者和部分参与者挂掉了，有两种情况：一是存活参与者触发超时，直接提交（此时若协调者发送的是回滚命令这时就会有一致性问题了）；一是协调者在存活参与者超时之前苏醒，这时协调者就不知道是该发送提交命令还是回滚命令（可以通过协调者写入日志来避免这种情况）。</li>
<li>当协调者挂掉后，由于参与者引入了超时机制，参与者不会一直等待。如果是参与者等待提交命令超时，那么参与者就会直接提交事务；如果是参与者等待预提交命令超时，那就该干啥干啥，参与者不受影响。这里有一个问题是：参与者无法判断是提交命令超时，还是回滚命令超时。如果是回滚命令超时，但是参与者执行的是提交命令，这时就会有数据不一致的问题。（因为有的提交了，有的回滚了）。</li>
</ul>
<mark class="hl-label green">总结</mark> 
<p> 3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。  <br></p>
<h2 id="5-3-TCC"><a href="#5-3-TCC" class="headerlink" title="5.3 TCC"></a>5.3 TCC</h2><p><strong>2PC和3PC都是数据库层面的，而TCC是业务层面的分布式事务</strong> 。TCC 指的是 Try - Confirm - Cancel：</p>
<ul>
<li>Try 指的是预留，即资源的预留和锁定， <mark class="hl-label pink">注意是预留</mark> 。</li>
<li>Confirm 指的是确认操作，这一步其实就是真正的执行了。</li>
<li>Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。</li>
</ul>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-11_09-52-48.png" class="" title="This is 2-th image.">
<p>其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。<br>比如说一个事务要执行A、B、C三个操作，那么先对三个操作执行预留动作。如果都预留成功了那么就执行确认操作，如果有一个预留失败那就都执行撤销动作。</p>
<p>可以看到流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应Try - Confirm - Cancel。</p>
<p>因此 <mark class="hl-label pink">TCC对业务的侵入较大和业务紧耦合</mark>   ，需要根据特定的场景和业务逻辑来设计相应的操作。</p>
<p>还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证 <mark class="hl-label pink">操作的幂等</mark>  。</p>
<p>相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写。不过也因为是在业务上实现的，所以 <mark class="hl-label pink">TCC可以跨数据库、跨不同的业务系统来实现事务</mark>   。</p>
<h2 id="5-4-本地消息表"><a href="#5-4-本地消息表" class="headerlink" title="5.4 本地消息表"></a>5.4 本地消息表</h2><p>本地消息表是利用 <mark class="hl-label pink">本地事务来实现分布式事务</mark>  。具体实现是将 <mark class="hl-label pink">业务的执行和将消息放入本地消息表的操作放入同一个本地事务中</mark>  ，这样可以保证消息放入本地消息表中一定是执行成功的。完了后，启动 <mark class="hl-label pink">后台任务定时读取本地消息表</mark>  筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。这时候有可能消息对应的操作不成功，因此也需要 <mark class="hl-label pink">重试</mark>  ，重试就得保证对应服务的方法是 <mark class="hl-label pink">幂等</mark>  的，而且一般重试会有最大次数， <mark class="hl-label pink">超过最大次数可以记录下报警让人工处理</mark>  。<br></p>
<p>本地消息表其实实现的是 <mark class="hl-label pink">最终一致性</mark>  ，容忍了数据 <mark class="hl-label pink">暂时不一致</mark>  的情况。</p>
<h2 id="5-5-消息事务"><a href="#5-5-消息事务" class="headerlink" title="5.5 消息事务"></a>5.5 消息事务</h2><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-11_10-33-30.png" class="" title="This is 2-th image.">
<mark class="hl-label pink">反查事务接口</mark>  的作用是：发送方过了一段时间并没有向 Broker 发送 Commit 或者 Rollback 消息，这时 Broker 可以通过反查事务接口去查询发送方事务是否成功，来决定半消息如何处理（是向订阅方发送 commit 命令还是丢弃半消息）。<br>

消息事务也是保证的 <mark class="hl-label pink">最终一致性</mark>  。<br>

## 5.6 最大努力通知

其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。<br>

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。<br>

事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。<br>

所以 <mark class="hl-label pink">最大努力通知其实只是表明了一种柔性事务的思想</mark> 
<p>即最大的努力想达成事务的最终一致。<br></p>
<p>适用于对时间不敏感的业务，例如短信通知。</p>
<h2 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h2><p>可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。<br></p>
<p>而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。<br></p>
<p>本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。<br></p>
<h2 id="5-8-SAGA"><a href="#5-8-SAGA" class="headerlink" title="5.8 SAGA"></a>5.8 SAGA</h2><p>SAGA 简介：</p>
<ul>
<li>只满足 ACD ，缺乏对于隔离性的支持。</li>
<li>只能保证 AP 即最终一致性。</li>
<li>通过使用 <strong>异步消息</strong> 来协调一系列本地事务，从而维护多个服务之间数据的最终一致性。</li>
<li>SAGA 是由一系列的本地事务来协调完成一个分布式事务的。每个参与者创建自己的本地事务完成后提交，然后出发下一个系统的本地事务直到所有的本地事务都完成，则分布式事务完成。</li>
<li>每个参与者在创建本地事务的同时也会提供补偿事务（即当触发回滚时，为了保证数据一致性而进行的本地事务操作的逆操作）。</li>
</ul>
<p>使用异步消息的好处是：可以确保 SAGA 的所有步骤都可以被执行，即使有一个或多个参与者暂时不可用。</p>
<p>关于隔离性：许多应用通过使用更低的隔离级别来提高性能。如在不同银行之间转账，也仅仅是遵守最终一致性的原则。</p>
<mark class="hl-label default">SAGA保证数据一致性：</mark> 
<p><br></p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_08-54-41.png" class="" title="This is 2-th image.">
<p><br></p>
<p>SAGA 事务的分类：</p>
<ul>
<li>可补偿事务：必须使用补偿事务回滚的事务</li>
<li>关键性事务：如果关键性事务成功，则 SAGA 将一直运行直到完成。关键性事务不见得是一个可补偿事务，或者可重复事务。但是它可以是最后一个可补偿事务或者第一个可重复事务。</li>
<li>可重复事务：在关键性事务之后的事务，保证成功。</li>
</ul>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_09-21-09.png" class="" title="This is 2-th image.">
<p>一种事务失败的情况：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_09-22-42.png" class="" title="This is 2-th image.">
<p><br></p>
<h3 id="5-8-1-SAGA的协调模式"><a href="#5-8-1-SAGA的协调模式" class="headerlink" title="5.8.1 SAGA的协调模式"></a>5.8.1 SAGA的协调模式</h3><h4 id="5-8-1-1-协同式-SAGA"><a href="#5-8-1-1-协同式-SAGA" class="headerlink" title="5.8.1.1 协同式 SAGA"></a>5.8.1.1 协同式 SAGA</h4><p>这种方式没有一个中央协调器告诉 SAGA 参与者应该怎么做。 SAGA 参与者仅通过订阅彼此的事件来做出相应的响应。</p>
<p>SAGA 实现给予发布 / 订阅的通信时需要考虑的一些问题： <a href="http://jeckfs.gitee.io/JeckFS/2022/06/13/微服务架构中的进程通信/">可靠的事件通信</a></p>
<ul>
<li><p>确保 SAGA 参与方将更新器本地数据库和发布事件作为数据库事务的一部分。即数据库更新和事件发布必须是原子的。因此为了可靠的通信， SAGA 参与方必须使用事务性消息（第三章内容）。</p>
</li>
<li><p>确保 SAGA 参与方必须能够接收到的每个事件映射到自己的数据上。如引入 <strong>相关性 ID</strong> ，使得订阅者根据该 ID 可以找到操作的数据。</p>
</li>
</ul>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-20-37.png" class="" title="This is 2-th image.">
<p>协同式 SAGA 的弊端：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-24-04.png" class="" title="This is 2-th image.">
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-24-21.png" class="" title="This is 2-th image.">
<h4 id="5-8-1-2-编排式-SAGA"><a href="#5-8-1-2-编排式-SAGA" class="headerlink" title="5.8.1.2 编排式 SAGA"></a>5.8.1.2 编排式 SAGA</h4><p>简介：<br>参与者的协调工作通过一个集中控制器来控制。 SAGA 编排器使用命令 / 异步响应方式告诉 SAGA 的参与方该做什么事情。当参与方完成操作后，会给编排器发送一个答复消息。编排器处理这个消息，并决定 SAGA 下一步的操作。</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-35-21.png" class="" title="This is 2-th image.">
<p>将 SAGA 编排器视为一个状态机：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-37-33.png" class="" title="This is 2-th image.">
<p>编排式 SAGA 的优点：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-40-27.png" class="" title="This is 2-th image.">
<p>编排式 SAGA 弊端：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-41-17.png" class="" title="This is 2-th image.">
<h3 id="5-8-2-解决-SAGA-隔离问题"><a href="#5-8-2-解决-SAGA-隔离问题" class="headerlink" title="5.8.2 解决 SAGA 隔离问题"></a>5.8.2 解决 SAGA 隔离问题</h3><p>所谓隔离指的是：可以确保同时执行多个事务的结果与顺序执行它们的结果相同。</p>
<p>缺乏隔离会引起其他 SAGA 可以更改当前 SAGA 正在访问的数据，因此会导致如下问题：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_10-44-12.png" class="" title="This is 2-th image.">
<h4 id="5-8-2-1-语义锁"><a href="#5-8-2-1-语义锁" class="headerlink" title="5.8.2.1 语义锁"></a>5.8.2.1 语义锁</h4><img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_11-03-58.png" class="" title="This is 2-th image.">
<p>如何处理已被锁定的记录：</p>
<ul>
<li>让 cancelOrder() 系统命令执行失败并告诉客户端 <strong>稍后再试</strong>。这样做的好处是易于实现。弊端是客户端必须实现重试逻辑。</li>
<li>让 cancelOrder() 处于阻塞状态，知道其他 SAGA 释放了语义锁。好处是重建了 ACID 事务提供的隔离。更新相同记录的 SAGA 被序列化，减少了编程工作量。另一个好处是消除了客户端重试的负担。缺点是应用必须管理锁，还必须实现死锁检测算法，该算法执行 SAGA 的回滚以打破死锁并重新执行它。</li>
</ul>
<h4 id="5-8-2-2-交换式更新"><a href="#5-8-2-2-交换式更新" class="headerlink" title="5.8.2.2 交换式更新"></a>5.8.2.2 交换式更新</h4><h4 id="5-8-2-3-悲观视图"><a href="#5-8-2-3-悲观视图" class="headerlink" title="5.8.2.3 悲观视图"></a>5.8.2.3 悲观视图</h4><p>重新排序 SAGA 的步骤，以 <strong>最大限度</strong> 地降低由于脏读而导致的业务风险。</p>
<p>如 create order saga 执行了可用信用额度的脏读，并创建了超过消费者信用额度的订单。为了降低发生这种情况的风险，可以重排 Cancel Order SAGA：</p>
<img src="/JeckFS/2022/05/24/MyPro/Snipaste_2022-06-13_11-20-09.png" class="" title="This is 2-th image.">
<h4 id="5-8-2-4-重读值"><a href="#5-8-2-4-重读值" class="headerlink" title="5.8.2.4 重读值"></a>5.8.2.4 重读值</h4><p>重读值可以防止丢失更新。类似于 CAS ，在 SAGA 更新前重新读取记录，看记录中的计数器是否更改，如果记录更改，则 SAGA 终止，然后回滚。</p>
<h4 id="5-8-2-5-版本文件"><a href="#5-8-2-5-版本文件" class="headerlink" title="5.8.2.5 版本文件"></a>5.8.2.5 版本文件</h4><h4 id="5-8-2-6-业务风险评级"><a href="#5-8-2-6-业务风险评级" class="headerlink" title="5.8.2.6 业务风险评级"></a>5.8.2.6 业务风险评级</h4><p>这是一种基于业务风险选择并发机制的策略。使用 SAGA 执行低风险请求，使用分布式事务执行高风险请求。</p>
<h1 id="6-优雅停机"><a href="#6-优雅停机" class="headerlink" title="6. 优雅停机"></a>6. 优雅停机</h1><p><strong>整体思路：</strong></p>
<p><img src="Snipaste_2022-06-11_11-54-14.png" width="70%" height="70%"></p>
<h1 id="7-关于高并发的一点思考"><a href="#7-关于高并发的一点思考" class="headerlink" title="7. 关于高并发的一点思考"></a>7. 关于高并发的一点思考</h1><mark class="hl-label default">架构决定并发上限，代码决定并发下线</mark> 
<p>第一点：通过网关做限流熔断、请求的单元分发。</p>
<p>当系统出现大量请求时，使用网关做 <mark class="hl-label default">限流熔断</mark>  。所谓 <strong>限流</strong> 指的是满足系统处理速度的近乎上限，对于多余的流量直接拒绝。所谓 <strong>熔断</strong> 指的是当前并发量超过了系统处理的极限，导致服务无法正常处理，这时服务不做业务处理统一返回固定报文。当然网关也可以使用 MQ 做削峰填谷。</p>
<p>第二点：数据单元化</p>
<p>以双十一场景为例，可以用商品 ID 做单元化（一个单元仅处理一定范围的商品 ID ）。同样数据库也做单元化。</p>
<p>这种情况会有一个问题是，一个事务如果涉及跨单元的情况下又可能导致不同单元的事务不一致。这种情况下，有很多种方式进行补救。现在提供一种方式： SAGA 模式，使用各个系统内的本地事务来实现分布式事务。当系统 A 有一个需要事务处理的交易，这时候一个系统一个系统的去询问相关系统是否可执行，当执行完（但是不能提交事务，防止后续系统产生异常时方便回滚），当所有系统都完成时一起提交事务。这个过程中 <strong>尽可能的提高通讯效率，当服务处理慢的时候提供熔断机制，以提高相应速度。</strong></p>
<p>第三点：代码层面</p>
<p>少访问数据库，少使用大事务，使用缓存。</p>
<p>第四点：数据一致性保证</p>
<p>数据库加锁做最后的保证。考虑到分布式锁不是特别成熟，因此在业务逻辑中对于无关紧要的需要做数据一致性限制的地方使用分布式锁。对于关键代码还是要靠数据库锁。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MErL680023FyJ7ovcQBlRw">参考链接</a></p>
<h1 id="8-日志脱敏"><a href="#8-日志脱敏" class="headerlink" title="8. 日志脱敏"></a>8. 日志脱敏</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS">YFS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS/2022/05/24/MyPro/">http://jeckfs.gitee.io/JeckFS/2022/05/24/MyPro/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeckfs.gitee.io/JeckFS" target="_blank">JeckFS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/JeckFS/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><div class="post_share"><div class="social-share" data-image="https://img1.baidu.com/it/u=2231100910,1753720113&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JeckFS/2022/05/28/Skywalking%E6%A2%B3%E7%90%86/"><img class="prev-cover" src="https://img2.baidu.com/it/u=48958987,1702342987&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Skywalking梳理</div></div></a></div><div class="next-post pull-right"><a href="/JeckFS/2022/04/15/Spring-SpEL/"><img class="next-cover" src="https://img0.baidu.com/it/u=4226681601,4255880919&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=641&amp;h=361" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring-SpEL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JeckFS/2020/08/10/WebSocket/" title="WebSocket"><img class="cover" src="https://img1.baidu.com/it/u=2656997690,163773951&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="title">WebSocket</div></div></a></div><div><a href="/JeckFS/2020/07/08/java%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="java商城秒杀系统设计与实现"><img class="cover" src="https://img2.baidu.com/it/u=208782341,2933630295&fm=253&fmt=auto&app=120&f=JPEG?w=641&h=361" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="title">java商城秒杀系统设计与实现</div></div></a></div><div><a href="/JeckFS/2022/03/11/miaosha/" title="miaosha"><img class="cover" src="https://img1.baidu.com/it/u=2709423071,2700494803&fm=253&fmt=auto&app=120&f=JPEG?w=500&h=281" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-11</div><div class="title">miaosha</div></div></a></div><div><a href="/JeckFS/2020/08/04/%E5%BE%AE%E4%BA%BA%E4%BA%8B/" title="微人事"><img class="cover" src="https://img2.baidu.com/it/u=1787475710,2159333383&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-04</div><div class="title">微人事</div></div></a></div><div><a href="/JeckFS/2020/07/09/java%E7%A7%92%E6%9D%80/" title="java秒杀"><img class="cover" src="https://img2.baidu.com/it/u=48958987,1702342987&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-09</div><div class="title">java秒杀</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/JeckFS/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YFS</div><div class="author-info__description">快乐每一天</div></div><div class="card-info-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">234</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">63</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.</span> <span class="toc-text">1. Spring 解决循环依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Apollo"><span class="toc-number">2.</span> <span class="toc-text">2. Apollo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 相关配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 客户端用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Apollo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Apollo 客户端设计原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 总体设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E4%B8%BA%E4%BB%80%E4%B9%88-Apollo-%E9%80%89%E7%94%A8-Eureka"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 为什么 Apollo 选用 Eureka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%90%84%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 各模块介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E9%85%8D%E7%BD%AE%E5%8F%91%E5%B8%83%E5%90%8E%E7%9A%84%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 配置发布后的实时推送设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Namespaces"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 Namespaces</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Skywalking"><span class="toc-number">3.</span> <span class="toc-text">3. Skywalking</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%B6%89%E5%8F%8A-Redis-%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%B7%A8%E4%B8%AD%E5%BF%83%E8%B0%83%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">4. 涉及 Redis 、数据库、跨中心调用时如何尽可能保持数据一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">5. 分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-2PC"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 2PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-3PC"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 3PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-TCC"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 TCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 本地消息表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 消息事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%80%BB%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">5.7 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-SAGA"><span class="toc-number">5.7.</span> <span class="toc-text">5.8 SAGA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-SAGA%E7%9A%84%E5%8D%8F%E8%B0%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.8.1 SAGA的协调模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-1-1-%E5%8D%8F%E5%90%8C%E5%BC%8F-SAGA"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">5.8.1.1 协同式 SAGA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-1-2-%E7%BC%96%E6%8E%92%E5%BC%8F-SAGA"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">5.8.1.2 编排式 SAGA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-2-%E8%A7%A3%E5%86%B3-SAGA-%E9%9A%94%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.2.</span> <span class="toc-text">5.8.2 解决 SAGA 隔离问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-1-%E8%AF%AD%E4%B9%89%E9%94%81"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">5.8.2.1 语义锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-2-%E4%BA%A4%E6%8D%A2%E5%BC%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">5.8.2.2 交换式更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-3-%E6%82%B2%E8%A7%82%E8%A7%86%E5%9B%BE"><span class="toc-number">5.7.2.3.</span> <span class="toc-text">5.8.2.3 悲观视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-4-%E9%87%8D%E8%AF%BB%E5%80%BC"><span class="toc-number">5.7.2.4.</span> <span class="toc-text">5.8.2.4 重读值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-5-%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">5.7.2.5.</span> <span class="toc-text">5.8.2.5 版本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-6-%E4%B8%9A%E5%8A%A1%E9%A3%8E%E9%99%A9%E8%AF%84%E7%BA%A7"><span class="toc-number">5.7.2.6.</span> <span class="toc-text">5.8.2.6 业务风险评级</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">6. 优雅停机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%85%B3%E4%BA%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">7. 关于高并发的一点思考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%97%A5%E5%BF%97%E8%84%B1%E6%95%8F"><span class="toc-number">8.</span> <span class="toc-text">8. 日志脱敏</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/10/06/%E9%A9%BE%E8%80%83-%E7%A7%91%E7%9B%AE%E4%B8%80/" title="驾考-科目一"><img src="https://img1.baidu.com/it/u=2709423071,2700494803&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="驾考-科目一"/></a><div class="content"><a class="title" href="/JeckFS/2022/10/06/%E9%A9%BE%E8%80%83-%E7%A7%91%E7%9B%AE%E4%B8%80/" title="驾考-科目一">驾考-科目一</a><time datetime="2022-10-06T12:14:56.000Z" title="发表于 2022-10-06 20:14:56">2022-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/09/27/%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B/" title="充血模型与贫血模型"><img src="https://img1.baidu.com/it/u=4132836557,2626223199&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="充血模型与贫血模型"/></a><div class="content"><a class="title" href="/JeckFS/2022/09/27/%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B/" title="充血模型与贫血模型">充血模型与贫血模型</a><time datetime="2022-09-27T05:59:41.000Z" title="发表于 2022-09-27 13:59:41">2022-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/09/16/vim%E6%89%8B%E5%86%8C/" title="vim手册"><img src="https://img1.baidu.com/it/u=4132836557,2626223199&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="vim手册"/></a><div class="content"><a class="title" href="/JeckFS/2022/09/16/vim%E6%89%8B%E5%86%8C/" title="vim手册">vim手册</a><time datetime="2022-09-16T01:57:05.000Z" title="发表于 2022-09-16 09:57:05">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/09/15/openGauss-%E7%AE%A1%E7%90%86%E5%8F%8A%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="openGauss-管理及开发工具"><img src="https://img1.baidu.com/it/u=2322041376,2548191196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="openGauss-管理及开发工具"/></a><div class="content"><a class="title" href="/JeckFS/2022/09/15/openGauss-%E7%AE%A1%E7%90%86%E5%8F%8A%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="openGauss-管理及开发工具">openGauss-管理及开发工具</a><time datetime="2022-09-15T08:35:23.000Z" title="发表于 2022-09-15 16:35:23">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/09/14/diff%E8%AF%A6%E8%A7%A3/" title="diff详解"><img src="https://img2.baidu.com/it/u=48958987,1702342987&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="diff详解"/></a><div class="content"><a class="title" href="/JeckFS/2022/09/14/diff%E8%AF%A6%E8%A7%A3/" title="diff详解">diff详解</a><time datetime="2022-09-14T09:56:54.000Z" title="发表于 2022-09-14 17:56:54">2022-09-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YFS</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/JeckFS/js/utils.js"></script><script src="/JeckFS/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/JeckFS/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>