<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Unix-进程通讯 | JeckFS</title><meta name="keywords" content="Unix"><meta name="author" content="YFS"><meta name="copyright" content="YFS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="解释  UDS：实现方式为 UNIX domain sockets。 •, UDS：实现方式为 pipes，UNIX domain sockets。 前十种用于同一个主机上的进程之间通讯；后两种用于不同主机上的进程通讯。  Pipes管道的限制  考虑到最大可能的移植性，虽然有的管道实现为全双工，但是历史上的管道都是半双工的。因此，在使用时尽可能的认为管道是使用半双工。 管道仅能用在具有亲属关系">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix-进程通讯">
<meta property="og:url" content="http://jeckfs.gitee.io/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/index.html">
<meta property="og:site_name" content="JeckFS">
<meta property="og:description" content="解释  UDS：实现方式为 UNIX domain sockets。 •, UDS：实现方式为 pipes，UNIX domain sockets。 前十种用于同一个主机上的进程之间通讯；后两种用于不同主机上的进程通讯。  Pipes管道的限制  考虑到最大可能的移植性，虽然有的管道实现为全双工，但是历史上的管道都是半双工的。因此，在使用时尽可能的认为管道是使用半双工。 管道仅能用在具有亲属关系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=3798217922,3880088897&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2022-12-03T11:33:28.000Z">
<meta property="article:modified_time" content="2022-12-09T12:36:58.437Z">
<meta property="article:author" content="YFS">
<meta property="article:tag" content="Unix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=3798217922,3880088897&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/JeckFS/img/favicon.png"><link rel="canonical" href="http://jeckfs.gitee.io/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/JeckFS/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/JeckFS/',
  algolia: undefined,
  localSearch: {"path":"/JeckFS/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unix-进程通讯',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-09 20:36:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">247</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">64</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/JeckFS/">JeckFS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unix-进程通讯</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-03T11:33:28.000Z" title="发表于 2022-12-03 19:33:28">2022-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-09T12:36:58.437Z" title="更新于 2022-12-09 20:36:58">2022-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/JeckFS/categories/Unix/">Unix</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unix-进程通讯"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="Snipaste_2022-12-03_19-34-06.png" width="100%" height="100%"></p>
<p><strong>解释</strong></p>
<ul>
<li>UDS：实现方式为 UNIX domain sockets。</li>
<li>•, UDS：实现方式为 pipes，UNIX domain sockets。</li>
<li>前十种用于同一个主机上的进程之间通讯；后两种用于不同主机上的进程通讯。</li>
</ul>
<h1 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h1><p><strong>管道的限制</strong></p>
<ul>
<li>考虑到最大可能的移植性，虽然有的管道实现为全双工，但是历史上的管道都是半双工的。因此，在使用时尽可能的认为管道是使用半双工。</li>
<li>管道仅能用在具有亲属关系的进程之间。如父子进程之间可通过管道通讯。</li>
</ul>
<p><img src="Snipaste_2022-12-03_19-59-44.png" width="100%" height="100%"></p>
<p>函数执行完成后，参数 fd 会存储两个描述符，<code>fd[0]</code> 用于读 <code>fd[1]</code> 用于写。<code>fd[1]</code> 的输出内容可以通过 <code>fd[0]</code> 进行读取。</p>
<p><img src="Snipaste_2022-12-03_20-05-20.png" width="100%" height="100%"></p>
<blockquote>
<p>可以通过 S_ISFIFO 宏来测试一个管道是否是 FIFO，若为成功则通过 fstat 函数获取的 stat 结构中 st_size 一般是未定义的。虽然有些系统在实现上会将读端的 st_size 置为可读数据的长度，但这是不可移植的。</p>
</blockquote>
<p><strong>半双工通道在父子进程之间的传输机制：</strong></p>
<p><img src="Snipaste_2022-12-03_20-15-16.png" width="100%" height="100%"></p>
<p><strong>管道的单向传输</strong></p>
<p><img src="Snipaste_2022-12-03_20-18-57.png" width="100%" height="100%"></p>
<p>当关闭管道的某一端时，应遵循如下规则：</p>
<ul>
<li>若从管道读取时该管道的写端被关闭，read 函数将返回 0 以表示所有数据已读取完毕。可以复制管道描述符以满足多个进程向管道中写入。</li>
<li>当向读端关闭的管道写入时，会触发 SIGPIPE 信号。若忽略该信号或者捕捉该信号然后从信号处理程序中返回，write 函数将返回 -1 并将 errno 置为 EPIPE。</li>
</ul>
<blockquote>
<p>PIPE_BUF 指定了内核中管道的大小。多进程之间不可以同时向管道中写入数据，即管道中仅能允许存在一个进程写入的数据。</p>
</blockquote>
<p><strong>示例 1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipe1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;		<span class="comment">/* parent */</span></span><br><span class="line">		sleep(<span class="number">3</span>);</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;					<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		n = read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">		write(STDOUT_FILENO, line, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">hello world <span class="comment">// 3秒后输出</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DEF_PAGER	<span class="string">&quot;/bin/more&quot;</span>		<span class="comment">/* default pager program */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipe2</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">int</span>		fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	*pager, *argv0;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: a.out &lt;pathname&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;								<span class="comment">/* parent */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);		<span class="comment">/* close read end */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* parent copies argv[1] to pipe */</span></span><br><span class="line">		<span class="keyword">while</span> (fgets(line, MAXLINE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			n = <span class="built_in">strlen</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (write(fd[<span class="number">1</span>], line, n) != n)</span><br><span class="line">				err_sys(<span class="string">&quot;write error to pipe&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ferror(fp))</span><br><span class="line">			err_sys(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line"></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end of pipe for reader */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;										<span class="comment">/* child */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);	<span class="comment">/* close write end */</span></span><br><span class="line">    <span class="comment">// 将一个描述符复制到另一个上，在复制之前应当比较该描述符的值是否已经具有所希望的值。若该描述符已具有所希望的值，并且调用了 dup2 和 close，那么该描述符的副本将关闭。</span></span><br><span class="line">		<span class="keyword">if</span> (fd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">      <span class="comment">// dup2 将子进程的标准输入设置为管道的读端。当 pager 程序执行时，pager 程序的标准输入将会是管道的读端。</span></span><br><span class="line">			<span class="keyword">if</span> (dup2(fd[<span class="number">0</span>], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">				err_sys(<span class="string">&quot;dup2 error to stdin&quot;</span>);</span><br><span class="line">			close(fd[<span class="number">0</span>]);	<span class="comment">/* don&#x27;t need this after dup2 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* get arguments for execl() */</span></span><br><span class="line">		<span class="comment">// if ((pager = getenv(&quot;PAGER&quot;)) == NULL)</span></span><br><span class="line">		pager = DEF_PAGER;</span><br><span class="line">		<span class="keyword">if</span> ((argv0 = <span class="built_in">strrchr</span>(pager, <span class="string">&#x27;/&#x27;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">			argv0++;		<span class="comment">/* step past rightmost slash */</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			argv0 = pager;	<span class="comment">/* no slash in pager */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pager = %s\targv0 = %s\n&quot;</span>, pager,argv0);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (execl(pager, argv0, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execl error for %s&quot;</span>, pager);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">$ ./main temp.lock</span><br><span class="line">pager = /bin/more       argv0 = more</span><br><span class="line">this is content from temp.lock</span><br></pre></td></tr></table></figure>
<p><strong>示例 3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用管道实现父子进程的同步</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>	pfd1[<span class="number">2</span>], pfd2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_WAIT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pipe(pfd1) &lt; <span class="number">0</span> || pipe(pfd2) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_PARENT</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (write(pfd2[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">WAIT_PARENT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>	c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read(pfd1[<span class="number">0</span>], &amp;c, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c != <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;WAIT_PARENT: incorrect data&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">TELL_CHILD</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (write(pfd1[<span class="number">1</span>], <span class="string">&quot;p&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">WAIT_CHILD</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>	c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read(pfd2[<span class="number">0</span>], &amp;c, <span class="number">1</span>) != <span class="number">1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c != <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;WAIT_CHILD: incorrect data&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例3管道使用示意图：</p>
<p><img src="Snipaste_2022-12-04_10-55-52.png" width="100%" height="100%"></p>
<h1 id="popen-and-pclose-Functions"><a href="#popen-and-pclose-Functions" class="headerlink" title="popen and pclose Functions"></a>popen and pclose Functions</h1><p><img src="Snipaste_2022-12-04_11-06-28.png" width="100%" height="100%"></p>
<p>这两个函数的主要作用是：创建一个管道、fork 一个子进程、关闭管道未使用的端、执行一个 shell 并运行命令、等待命令执行结束。</p>
<p>popen：fork 一个子进程、执行 cmdstring 命令并返回一个标准 IO 的 FILE 指针。</p>
<p>pclose：关闭标准 IO 流，等待命令执行完毕，并返回 shell 的终止状态。若 shell 不能被执行，则 pclose 返回的终止状态如同 shell 执行 exit(127) 一样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数 r 取值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">文件指针连接到 cmdstring 执行结果的标准输出</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">文件指针连接到 cmdstring 的标准输入</td>
</tr>
</tbody>
</table>
</div>
<p>FILE 指针的读写权限由 popen 函数的 type 参数控制。</p>
<p><img src="Snipaste_2022-12-04_11-14-33.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-04_11-14-13.png" width="100%" height="100%"></p>
<p><strong>示例1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	PAGER	<span class="string">&quot;$&#123;PAGER:-more&#125;&quot;</span> <span class="comment">/* environment variable, or default */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">popen2</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line">	FILE	*fpin, *fpout;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: a.out &lt;pathname&gt;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fpin = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;can&#x27;t open %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fpout = popen(PAGER, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) <span class="comment">// fork 一个子进程</span></span><br><span class="line">		err_sys(<span class="string">&quot;popen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy argv[1] to pager */</span></span><br><span class="line">	<span class="keyword">while</span> (fgets(line, MAXLINE, fpin) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fputs</span>(line, fpout) == EOF)</span><br><span class="line">			err_sys(<span class="string">&quot;fputs error to pipe&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ferror(fpin))</span><br><span class="line">		err_sys(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pclose(fpout) == <span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pclose error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">$ ./main temp.lock</span><br><span class="line"><span class="comment">// 使用 more 命令输出 temp.lock 中的内容</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pointer to array allocated at run-time.</span></span><br><span class="line"><span class="comment"> * 通过描述符可以索引到对应的子进程 ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span>	*childpid = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * From our open_max(), &#123;Prog openmax&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span>		maxfd;</span><br><span class="line"></span><br><span class="line">FILE *</span><br><span class="line"><span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		i;</span><br><span class="line">	<span class="type">int</span>		pfd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	FILE	*fp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* only allow &quot;r&quot; or &quot;w&quot; */</span></span><br><span class="line">	<span class="keyword">if</span> ((type[<span class="number">0</span>] != <span class="string">&#x27;r&#x27;</span> &amp;&amp; type[<span class="number">0</span>] != <span class="string">&#x27;w&#x27;</span>) || type[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;		<span class="comment">/* first time through */</span></span><br><span class="line">		<span class="comment">/* allocate zeroed out array for child pids */</span></span><br><span class="line">		maxfd = open_max(); <span class="comment">// 获取能够打开的最大描述符数量</span></span><br><span class="line">		<span class="keyword">if</span> ((childpid = <span class="built_in">calloc</span>(maxfd, <span class="keyword">sizeof</span>(<span class="type">pid_t</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(pfd) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by pipe() */</span></span><br><span class="line">	<span class="keyword">if</span> (pfd[<span class="number">0</span>] &gt;= maxfd || pfd[<span class="number">1</span>] &gt;= maxfd) &#123; <span class="comment">// 达到最大描述符数量限制时，将 errno 置为 EMFILE 并返回 null</span></span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		errno = EMFILE;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);	<span class="comment">/* errno set by fork() */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;							<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">if</span> (*type == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">			close(pfd[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">1</span>] != STDOUT_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">				close(pfd[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			close(pfd[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (pfd[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">				dup2(pfd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">				close(pfd[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* close all descriptors in childpid[] */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxfd; i++)</span><br><span class="line">			<span class="keyword">if</span> (childpid[i] &gt; <span class="number">0</span>)</span><br><span class="line">				close(i);</span><br><span class="line"></span><br><span class="line">		execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdstring, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">		_exit(<span class="number">127</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent continues... */</span></span><br><span class="line">	<span class="keyword">if</span> (*type == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">		close(pfd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">0</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		close(pfd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> ((fp = fdopen(pfd[<span class="number">1</span>], type)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fileno(fp)] = pid;	<span class="comment">/* remember child pid for this fd */</span></span><br><span class="line">	<span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pclose</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd, stat;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (childpid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* popen() has never been called */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = fileno(fp);</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= maxfd) &#123; <span class="comment">// 文件描述符超过最大数量限制</span></span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* invalid file descriptor */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((pid = childpid[fd]) == <span class="number">0</span>) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);		<span class="comment">/* fp wasn&#x27;t opened by popen() */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	childpid[fd] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (fclose(fp) == EOF)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (waitpid(pid, &amp;stat, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);	<span class="comment">/* error other than EINTR from waitpid() */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(stat);	<span class="comment">/* return child&#x27;s termination status */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>popen 函数不能被 set-user-ID 或 set-group-ID 程序调用。否则 popen 等价于调用 <code>execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, NULL);</code>。execl 的执行环境是继承子调用者的，因此 set-ID 文件模式会提高命令执行的权限导致一些安全问题。</p>
<blockquote>
<p>在 exec 前后实际用户 ID 和实际组 ID 保持不变，而有效 ID 是否改变则取决于所执行程序文件的设置用户 ID 位和设置组 ID 位是否设置。若新程序的设置用户 ID 位已经设置，则有效用户 ID 变成程序文件所有者的 ID；否则有效用户 ID 不变。对组  ID 的处理方式与此相同。</p>
</blockquote>
<p>popen 函数特别适合用于简单地将正在运行的命令的输入或者输出转换成另一种格式。如大小写转换。</p>
<p><img src="Snipaste_2022-12-04_16-27-39.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将此程序编译成 myuclc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isupper</span>(c))</span><br><span class="line">			c = <span class="built_in">tolower</span>(c);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">putchar</span>(c) == EOF)</span><br><span class="line">			err_sys(<span class="string">&quot;output error&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			fflush(<span class="built_in">stdout</span>); <span class="comment">// 下节协同进程会说明原因</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line">	FILE	*fpin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fpin = popen(<span class="string">&quot;/home/yfs/data/learning/kernal/exercise/output/myuclc&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;popen error&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">&quot;prompt&gt; &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>); <span class="comment">// 由于标准输出是行缓冲，这里需要刷新缓存</span></span><br><span class="line">		<span class="keyword">if</span> (fgets(line, MAXLINE, fpin) == <span class="literal">NULL</span>)	<span class="comment">/* read from pipe */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">			err_sys(<span class="string">&quot;fputs error to pipe&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pclose(fpin) == <span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pclose error&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">$ ./main</span><br><span class="line">prompt&gt; HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">prompt&gt; WERWERWE</span><br><span class="line">werwerwe</span><br><span class="line">prompt&gt; WE ARE STUDENT!</span><br><span class="line">we are student!</span><br><span class="line">prompt&gt; </span><br></pre></td></tr></table></figure>
<h1 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h1><p>当一个程序即产生某个过滤程序的输入，又读取该过滤程序的输出时，该过滤器就变成了协同进程。协同进程通常在 shell 的后台运行，其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen 函数只提供连接到另一个进程的标准输入或标准输出的一个单向管道，而协同进程则有连接到另一个进程的两个单向管道：一个连接到其标准输入，另一个连接到其标准输出。我们将数据写到其标准输入，经其处理后，再从其标准输出读取数据。</p>
<p><strong>示例1</strong></p>
<p><img src="Snipaste_2022-12-05_09-35-58.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的过滤器(协同进程)，用于计算两个数的和。并编译成可执行程序 add2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n, int1, int2;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, line, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		line[n] = <span class="number">0</span>;		<span class="comment">/* null terminate */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%d%d&quot;</span>, &amp;int1, &amp;int2) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(line, <span class="string">&quot;%d\n&quot;</span>, int1 + int2);</span><br><span class="line">			n = <span class="built_in">strlen</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (write(STDOUT_FILENO, line, n) != n)</span><br><span class="line">				err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (write(STDOUT_FILENO, <span class="string">&quot;invalid args\n&quot;</span>, <span class="number">13</span>) != <span class="number">13</span>)</span><br><span class="line">				err_sys(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 15.18</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>	<span class="title function_">sig_pipe</span><span class="params">(<span class="type">int</span>)</span>;		<span class="comment">/* our signal handler */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipe4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n, fd1[<span class="number">2</span>], fd2[<span class="number">2</span>];</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (signal(SIGPIPE, sig_pipe) == SIG_ERR)</span><br><span class="line">		err_sys(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe(fd1) &lt; <span class="number">0</span> || pipe(fd2) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;							<span class="comment">/* parent */</span></span><br><span class="line">		close(fd1[<span class="number">0</span>]);</span><br><span class="line">		close(fd2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (fgets(line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			n = <span class="built_in">strlen</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (write(fd1[<span class="number">1</span>], line, n) != n)</span><br><span class="line">				err_sys(<span class="string">&quot;write error to pipe&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> ((n = read(fd2[<span class="number">0</span>], line, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">				err_sys(<span class="string">&quot;read error from pipe&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">				err_msg(<span class="string">&quot;child closed pipe&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			line[n] = <span class="number">0</span>;	<span class="comment">/* null terminate */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fputs</span>(line, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">				err_sys(<span class="string">&quot;fputs error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ferror(<span class="built_in">stdin</span>))</span><br><span class="line">			err_sys(<span class="string">&quot;fgets error on stdin&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;									<span class="comment">/* child */</span></span><br><span class="line">		close(fd1[<span class="number">1</span>]);</span><br><span class="line">		close(fd2[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (fd1[<span class="number">0</span>] != STDIN_FILENO) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dup2(fd1[<span class="number">0</span>], STDIN_FILENO) != STDIN_FILENO)</span><br><span class="line">				err_sys(<span class="string">&quot;dup2 error to stdin&quot;</span>);</span><br><span class="line">			close(fd1[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fd2[<span class="number">1</span>] != STDOUT_FILENO) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dup2(fd2[<span class="number">1</span>], STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">				err_sys(<span class="string">&quot;dup2 error to stdout&quot;</span>);</span><br><span class="line">			close(fd2[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (execl(<span class="string">&quot;./add2&quot;</span>, <span class="string">&quot;add2&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			err_sys(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 kill 掉 add2（协同进程），当本程序接收到用户输入的</span></span><br><span class="line"><span class="comment">// 两个数字后，信号处理程序将被激活，因为本程序向管道写入</span></span><br><span class="line"><span class="comment">// 数据后并没有其他进程读取。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_pipe</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE caught\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">./main</span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 执行 kill -QUIT [the pid of add2]。add2进程将会变成僵尸进程</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line">SIGPIPE caught</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 15.19</span></span><br><span class="line"><span class="comment">// 将协同进程换成标准 IO 库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">add1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		int1, int2;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在标准输入上的 fgets 将会导致标准 IO 库分配一个</span></span><br><span class="line">	<span class="comment">// buffer。由于标准输入是一个管道，标准 IO 库默认</span></span><br><span class="line">	<span class="comment">// 将缓冲类型设置为全缓冲。标准输出也是如此。当 </span></span><br><span class="line">	<span class="comment">// add1 程序由于从标准输入读取而阻塞时，主程序 </span></span><br><span class="line">	<span class="comment">// 15.18 也由于从管道中读取计算结果而阻塞，因此陷入死锁。</span></span><br><span class="line">	<span class="keyword">while</span> (fgets(line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%d%d&quot;</span>, &amp;int1, &amp;int2) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, int1 + int2) == EOF)</span><br><span class="line">				err_sys(<span class="string">&quot;printf error&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">printf</span>(<span class="string">&quot;invalid args\n&quot;</span>) == EOF)</span><br><span class="line">				err_sys(<span class="string">&quot;printf error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 15.19 改造</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">add1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		int1, int2;</span><br><span class="line">	<span class="type">char</span>	line[MAXLINE];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当输入一行后会让 fgets 返回；</span></span><br><span class="line">	<span class="comment">// 当输出一行后，会让printf 立即调用 fflush 刷新</span></span><br><span class="line">	<span class="keyword">if</span> (setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;setvbuf error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;setvbuf error&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%d%d&quot;</span>, &amp;int1, &amp;int2) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, int1 + int2) == EOF)</span><br><span class="line">				err_sys(<span class="string">&quot;printf error&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">printf</span>(<span class="string">&quot;invalid args\n&quot;</span>) == EOF)</span><br><span class="line">				err_sys(<span class="string">&quot;printf error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前的情况是，我们可以直接修改 add1 的源码，当不能修改其源码时应该如何做？</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 add1 程序替换成 awk 程序，且我们无法修改 awk 程序</span></span><br><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line">&#123; print <span class="variable">$1</span> + <span class="variable">$2</span> &#125;</span><br></pre></td></tr></table></figure>
<p>解决方法是：使协同进程认为它的标准输入和标准输出都是连接到一个终端中即可。这样协同进程中的标准 IO 例程变为行缓冲。具体做法会在伪终端那一章节中介绍。</p>
<h1 id="FIFOs"><a href="#FIFOs" class="headerlink" title="FIFOs"></a>FIFOs</h1><p>FIFOs 有时被称为命名管道。无命名管道（pipe）仅能被用在有关联关系（管道由互相通信的两个进程的共同祖先创建）的进程中。而 FIFOs 可以用在无关联关系的进程中。</p>
<p>stat 结构体中的 st_mode 属性可以用来标识文件是否是 FIFO（可通过 S_ISFIFO 宏进行检测）。</p>
<p><img src="Snipaste_2022-12-05_10-35-20.png" width="100%" height="100%"></p>
<p><strong>参数说明</strong></p>
<p>mode 参数同 open() 的 mode 参数。</p>
<p><strong>函数说明</strong><br>mkfifoat 函数与 mkfifo 函数基本类似。不同之处在于 mkfifoat 函数可以相对于文件描述符 fd 所在的目录创建一个 FIFO 文件。具体如下：</p>
<ul>
<li>若 path 为绝对路径，则参数 fd 则被忽略，此时 mkfifoat 与 mkfifo 类似。</li>
<li>若 path 参数为相对路径且 fd 参数是一个已打开目录的有效文件描述符，则路径名由相对于 fd 指定目录来确定。</li>
<li>若 path 参数为相对路径且 fd 参数具有 AT_FDCWD 标志，则路径名相对于当前工作目录来确定，此时 mkfifoat 与 mkfifo 类似。</li>
</ul>
<blockquote>
<p>由 mkfifoat 或者 mkfifo 函数创建的 FIFO 文件，其相关的操作与普通文件一样，如 open、close、read、write、unlink 等。</p>
</blockquote>
<p><strong>open FIFO 文件时指定阻塞标志对程序的影响：</strong></p>
<ul>
<li>没有指定 O_NONBLOCK，只读 open 要阻塞到其他进程写入这个 FIFO 为止；只写 open 要阻塞到其他进程读取这个 FIFO 为止。</li>
<li>若指定了 O_NONBLOCK，只读 open 立即返回。若没有进程为读而打开一个 FIFO 那么只写 open 将返回 -1，并将 errno 设置为 ENXIO</li>
</ul>
<p>向没有进程读取的 FIFO 文件中写入，会触发 SIGPIPE 信号。当最后一个 FIFO 文件的写进程关闭该 FIFO 文件时，该 FIFO 文件的的读进程会收到到达文件尾端的信息。</p>
<p><strong>多个写进程交叉写入 FIFO 的问题：</strong></p>
<p>可以使用 PIPE_BUF 指定能够原子写入到 FIFO 文件的最大数据量。</p>
<p><strong>FIFO 的应用</strong></p>
<ul>
<li>用于 shell 命令中，从一个 shell 传递数据到另一个中，且不创建中间态的临时文件。</li>
<li>作为一个数据中转站，用于在客户端和服务端传递数据。</li>
</ul>
<p><strong>示例1：使用 FIFOs 在一系列 shell 命令中复制输出流</strong></p>
<p>使用 FIFOs 实现非线性的进程间连接。（管道只能实现线性连接，如 shell 命令通过管道符 <code>|</code> 实现线性连接）。</p>
<p>实现类似 tee 的功能：</p>
<p><img src="Snipaste_2022-12-05_14-55-03.png" width="100%" height="100%"></p>
<blockquote>
<p><code>tee</code> 会将标准输入拷贝到标准输出以及命令指定的文件中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifo1</span><br><span class="line">prog3 &lt; fifo1 &amp; # prog3 从 FIFO 中读</span><br><span class="line">prog1 &lt; infile | tee fifo1 | prog2 # 执行 prog1 并将其输出通过 tee 命令发送到 FIFO 和 prog2 中</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img src="Snipaste_2022-12-05_15-02-47.png" width="100%" height="100%"></p>
<p><strong>示例2：使用 FIFOs 实现客户端与服务端之间的通讯</strong></p>
<p><img src="Snipaste_2022-12-05_15-06-18.png" width="100%" height="100%"></p>
<blockquote>
<p>由于同一个 FIFO 文件存在多个写进程，因此每个发送到 FIFO 的请求大小必须在 PIPE_BUF 字节之内，以防止多个写进程的交叉写入问题。</p>
</blockquote>
<p><strong>服务器端与多客户端之间的交互实现</strong></p>
<p><img src="Snipaste_2022-12-05_15-11-27.png" width="100%" height="100%"></p>
<p>客户端发送请求时携带进程 ID，服务端为每个客户端创建不同的 FIFO 文件（如 /tmp/tmp/serv1.xxxxxx）。为了防止客户端挂掉导致 FIFO 一直遗留在系统中，服务端需要捕捉 SIGPIPE 信号，以监听是否存在读进程（客户端）。</p>
<p>【注意】若服务端创建只读的 FIFO，那么每次客户端的数量减少至 0 时，服务端的 read 调用将会收到 FIFO 文件结束的信息。为了阻塞这种情况发生，服务端在调用 open 函数时应指定其读写权限。</p>
<h1 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h1><p>XSI IPC 一般是：消息队列、信号量、共享内存。</p>
<h2 id="Identifiers-and-Keys"><a href="#Identifiers-and-Keys" class="headerlink" title="Identifiers and Keys"></a>Identifiers and Keys</h2><p>每个内核中的 IPC 结构（消息队列、信号量、共享内存）都用一个非负整数来进行标识（identifier）。identifier 一直是递增的，不管一个 IPC 结构是创建还是销毁，当其达到最大值时又会从 0 开始递增。</p>
<p>identifier 只是 IPC 对象的一种内部表示，通过 IPC 通信的进程之间需要有一个外部的 IPC 对象的命名。因此，在外部，通过 key 来关联一个 IPC 对象。</p>
<p>当通过 msgget、semget、shmget 创建 IPC 结构时也必须指定其 key。key 的数据类型为 key_t（位于 sys/types.h 中，通常定义为一个 long 类型。内核会将 key 转换成 identifier）。</p>
<p>CS 中使用 IPC 的几种方式：</p>
<ol>
<li>服务端通过指定 IPC_PRIVATE key 来创建一个新的 IPC 结构，并将其返回的 identifier 存储在某个文件中，以使得客户端可以获取。<br>在父子进程中，父进程通过指定 IPC_PRIVATE 创建一个 IPC 结构，返回的 identifier 可以在子进程中使用。此外，子进程也可以将 identifier 通过 exec 函数传递给新程序。</li>
<li>在公用头文件中定义一个客户端和服务端都认可的键。然后服务端指定此键创建一个新的 IPC 结构。<br>这种方式的缺点是：该键可能已经与一个 IPC 结构相结合，这时 get 函数（msgget、semget、shmget）出错返回。服务端必须处理这种错误，删除已经存在的 IPC 结构，然后再尝试创建它。</li>
<li>使用 ftok 函数通过一个路径名和项目 ID （0～255的一个字符）来生成一个 key（可用于第2步中）。</li>
</ol>
<p><img src="Snipaste_2022-12-05_16-23-44.png" width="100%" height="100%"></p>
<p><strong>参数说明</strong><br>path：必须引用一个现存的文件。<br>id：生成 key 时仅使用 id 参数的低 8 位。</p>
<p><strong>函数说明</strong></p>
<p>创建方法：通常是取给定 pathname 的 stat 结构中的 st_dev 和 st_ino 的部分内容，然后与项目 ID 组合在一起。<br>两个不同文件的路径名在使用同一个项目 ID 的情况下，有可能会创建出相同的 key。因为 i 节点编号和 key 通常存储在一个 long 类型中，因此创建一个 key 时可能会丢失信息。</p>
<p><img src="Snipaste_2022-12-05_16-55-22.png" width="100%" height="100%"></p>
<h2 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h2><p>XSI IPC 为每个 IPC 结构关联了一个 ipc_perm 结构，该结构规定了权限和所有者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整定义见 sys/ipc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">     <span class="type">uid_t</span>  uid;  <span class="comment">/* owner’s effective user ID */</span></span><br><span class="line">     <span class="type">gid_t</span>  gid;  <span class="comment">/* owner’s effective group ID */</span></span><br><span class="line">     <span class="type">uid_t</span>  cuid; <span class="comment">/* creator’s effective user ID */</span></span><br><span class="line">     <span class="type">gid_t</span>  cgid; <span class="comment">/* creator’s effective group ID */</span></span><br><span class="line">     <span class="type">mode_t</span> mode; <span class="comment">/* access modes */</span></span><br><span class="line">	 ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在创建 IPC 结构时，对所有字段都赋初值。以后可调用 msgctl、semctl、shmctl 修改 uid、gid、mode 字段（调用进程必须是 IPC 结构的创建者或超级用户）。修改这些字段类似于对文件调用 chown 和 chmod。</p>
<p>mode 字段的取值类如下：</p>
<p><img src="Snipaste_2022-12-05_17-06-16.png" width="100%" height="100%"></p>
<p>对于消息队列和共享存储使用术语 “读” 和 “写”，而信号量使用术语 “读” 和 “更改”。</p>
<h2 id="结构限制"><a href="#结构限制" class="headerlink" title="结构限制"></a>结构限制</h2><p>3 种形式的 XSI IPC 都有内置限制，大多数限制可通过重新配置内核来改变。</p>
<p>FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8 提供了 sysctl 命令来观察和修改内核配置参数。<br>Solaris 10 中可以使用 prcctl 命令来改变内核 IPC 限制。</p>
<p>在 Linux 中，可通过 <code>ipcs -l</code> 来显式 IPC 相关的限制。<br>在 FreeBSD 中，等效的命令是 <code>ipcs -T</code><br>在 Solaris 中，可通过运行 <code>sysdef -y</code> 来找到可调节参数。</p>
<h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><p>缺点：</p>
<ul>
<li>IPC 结构是在系统范围内起作用的，没有引用计数。即当相关进程终止后，它们会一直保留在系统中直到发生下列动作为止（以消息队列为例）：<ul>
<li>由某个进程调用 msgrcv 或 msgctl 读消息或删除消息队列</li>
<li>某个进程执行 ipcrm 命令删除消息队列</li>
<li>正在自举的系统删除消息队列。<blockquote>
<p>管道：当最后一个引用管道的进程终止时，管道就被安全地删除；<br>FIFO：最后一个引用 FIFO 的进程终止时，虽然 FIFO 的名字仍保留在系统中，直至被显式删除，但留在 FIFO 中的数据已被删除了。</p>
</blockquote>
</li>
</ul>
</li>
<li>这些 IPC 结构在文件系统中没有名字。无法使用操作文件的函数来访问或修改它们的属性。由于 IPC 不使用文件描述符，因此不能对他们使用多路转接 IO 函数（select、poll），因此很难一次使用一个以上这样的 IPC 结构，或者在文件或设备 IO 中使用这样的 IPC 结构。因此从多个消息队列中获取消息时只能使用忙等的方式。<ul>
<li>为了增加相关支持，又增加了十几个系统调用：msgget、semop、shmat；ipcs、ipcrm。</li>
</ul>
</li>
</ul>
<p>优点：<br>可靠、流控制的、面向记录的。可以用非先进先出次序处理。</p>
<p><img src="Snipaste_2022-12-05_17-30-50.png" width="100%" height="100%"></p>
<ul>
<li>无连接：指的是无需先调用某种形式的打开函数就能发送消息的能力。（因为需要有某种技术来获取 identifier ，所以并不认为 IPC 是无连接的）</li>
<li>可靠的：指的是所有的 IPC 都被限制在一台主机上，因此是可靠的。当消息通过网络传送时，存在丢失消息的可能性。</li>
<li>流控制：指的是若系统资源（缓冲区）短缺，或者若接受进程不能再接受更多消息，则发送进程就要休眠。当流控制条件消失时，发送进程应自动唤醒。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><blockquote>
<p>本节将消息队列标识符称为队列 ID</p>
</blockquote>
<p>消息队列操作函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">消息队列操作函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">msgget</td>
<td style="text-align:center">创建一个新队列或打开一个现有队列</td>
</tr>
<tr>
<td style="text-align:center">msgsnd</td>
<td style="text-align:center">将新消息添加到队列尾端</td>
</tr>
<tr>
<td style="text-align:center">msgrcv</td>
<td style="text-align:center">从队列中读取消息</td>
</tr>
</tbody>
</table>
</div>
<p>每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数（对应于长度）。</p>
<p>可以按照先进先出次序取消息，也可以按照消息类型字段取消息。</p>
<p>队列结构体：</p>
<p><img src="Snipaste_2022-12-05_19-41-56.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-05_19-45-52.png" width="100%" height="100%"></p>
<blockquote>
<p>“导出的”表示这种限制来源于其他限制。系统中的最大消息数是根据<code>最大队列数</code>和<code>队列中所允许的最大数据量</code>来决定的。其中<code>最大队列数</code> 还要根据系统上安装的 RAM 的数量来决定。</p>
</blockquote>
<p><img src="Snipaste_2022-12-05_19-48-39.png" width="100%" height="100%"></p>
<p>在创建新队列时，要初始化的 msqid_ds 结构如下：</p>
<ul>
<li>ipc_perm 结构</li>
<li>msg_qnum、msg_lspid、msg_lrpid、msg_stime、msg_rtime 都设置为 0</li>
<li>msg_ctime 设置为当前时间</li>
<li>msg_qbytes 设置为系统限制值</li>
</ul>
<p><img src="Snipaste_2022-12-05_20-02-19.png" width="100%" height="100%"></p>
<p>msgctl 和另外两个于信号量及共享存储有关的额函数（semctl 和 shmctl）都是 XSI IPC 的类似 ioctl 的函数（亦即垃圾桶函数）。</p>
<p>cmd 参数指定对 msqid 指定的队列要执行的命令：<br><img src="Snipaste_2022-12-05_20-49-43.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-05_20-50-02.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-05_20-50-24.png" width="100%" height="100%"></p>
<p>ptr 参数指向一个结构体，它包含了正的整型消息类型，其后紧接着的是消息数据（若 nbytes 是 0，则无消息数据）。若发送的最长消息是 512 B，则可定义下列结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> mtype; <span class="comment">/* positive message type */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>flag 参数可指定为 IPC_NOWAIT。若消息队列已满（或者是队列中的消息综述等于系统限制值，或队列中的字节总数等于系统限制值），则指定 IPC_NOWAIT 使得 msgsnd 立即出错返回 EAGAIN。若没有指定 IPC_NOWAIT，则进程会一直阻塞到：有空间可以容纳要发送的消息；或者从系统中删除了此队列（会返回 EIDRM 错误，〈标识符被删除〉）；或者捕捉到一个信号，并从信号处理程序返回（会返回 EINTR 错误）。</p>
<p>当消息队列被删除后，使用该消息队列的进程若再次对该队列进行操作会导致出错（即删除消息队列时，有可能其他进程还在使用该消息队列）。信号量机制也使用类似的方式处理其删除。</p>
<p>当 msgsnd 返回成功时，消息队列相关的 msqid_ds 结构会随之更新，主要包括调用的进程 ID（msg_lspid）、调用的时间（msg_stime）、队列中新增的消息（msg_qnum）。</p>
<hr>
<p><img src="Snipaste_2022-12-05_21-15-57.png" width="100%" height="100%"></p>
<p><strong>ptr 参数</strong>指向一个包含消息类型和用于存储实际消息数据的缓冲区的结构体。</p>
<p><strong>nbytes 参数</strong>指定数据缓冲区的长度。若返回的消息长度大于 nbytes，且在 flag 中设置了 MSG_NOERROR 位时，则该消息会被截断。若没有设置该标志，而消息又太长，则出错返回 E2BIG（消息仍留队列中）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>参数 type</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">type == 0</td>
<td style="text-align:center">返回队列中的第一个消息</td>
</tr>
<tr>
<td style="text-align:center">type &gt; 0</td>
<td style="text-align:center">返回队列中消息类型为 type 的第一个消息</td>
</tr>
<tr>
<td style="text-align:center">type &lt; 0</td>
<td style="text-align:center">返回毒烈中消息类型值小于等于 type 绝对值的消息，若这种消息有若干个，则取类型值最小的消息。可以实现按优先级读取消息</td>
</tr>
</tbody>
</table>
</div>
<p>若消息队列由多个客户端和一个服务端使用，那么 type 字段可用来包含客户进程的进程 ID（只要进程 ID 可以存放在长整型中）。</p>
<p><strong>flag 参数</strong>可指定为 IPC_NOWAIT，使操作不阻塞。这样，当没有锁指定类型的消息可用时，则 msgrcv 返回 -1，errno 设置为 ENOMSG。若没有指定 IPC_NOWAIT，则进程会一直阻塞到有了指定类型的消息，或者从系统中删除了此队列（返回 -1，errno 置为 EIDRM），或者捕捉到一个信号并从信号处理程序中返回（这会导致 msgrcv 返回 -1，errno 置为 EINTR）。</p>
<p>msgrcv 成功执行时，内核会更新与该消息队列相关联的 msgid_ds 结构，主要包括调用者的进程 ID（msg_lrpid）、调用时间（msg_rtime）、指示队列中的消息数减少 1 个（msg_qnum）。</p>
<h1 id="XSI-信号量"><a href="#XSI-信号量" class="headerlink" title="XSI 信号量"></a>XSI 信号量</h1><p>XSI 信号量要求：</p>
<ul>
<li>信号量并非是单个的非负值，而必须定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量。</li>
<li>信号量的创建（semget）是独立于它的初始化（semctl）的。缺点是：不能原子地创建一个信号量集合，并对该集合中的各个信号量赋初值。</li>
<li>即使没有进程正在使用各种形式的 XSI IPC，它们仍旧会存在。有的程序在终止时并没有释放已经分配的信号量。</li>
</ul>
<p>每个信号量集合维护着一个 semid_ds 结构：</p>
<p><img src="Snipaste_2022-12-05_22-02-23.png" width="100%" height="100%"></p>
<p>每个信号量用一个无名结构来表示：</p>
<p><img src="Snipaste_2022-12-05_22-04-33.png" width="100%" height="100%"></p>
<p>影响信号量的系统限制：</p>
<p><img src="Snipaste_2022-12-05_22-05-03.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-05_22-08-17.png" width="100%" height="100%"></p>
<p>当创建新集合时，要对 semid_ds 结构的下列成员赋初值：</p>
<ul>
<li>初始化 ipc_perm 结构。</li>
<li>sem_otime 设置为 0</li>
<li>sem_ctime 设置为当前时间</li>
<li>sem_nsems 设置为 nsems（nsems 是该集合中的信号量数。若创建新集合（一般在服务器进程中），则必须指定 nsems。若引用现有集合（一个客户进程），则将 nsems 指定为 0）</li>
</ul>
<hr>
<p><img src="Snipaste_2022-12-05_22-11-36.png" width="100%" height="100%"></p>
<p>是否指定 arg 参数取决于所请求的命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">     <span class="type">int</span>               val;   <span class="comment">/* for SETVAL */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>  *<span class="title">buf</span>;</span>   <span class="comment">/* for IPC_STAT and IPC_SET */</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">short</span>   *<span class="built_in">array</span>; <span class="comment">/* for GETALL and SETALL */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常 union semun 由程序自己定义。但在 FreeBSD 8.0 中，senum 已由 sys/sem.h 定义好。</p>
</blockquote>
<p>cmd 参数的取值如下。这些命令时运行在 semid 指定的信号量集合上的。</p>
<p><img src="Snipaste_2022-12-05_22-20-22.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-05_22-21-21.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span>  sem_num;  <span class="comment">/* member # in set (0, 1, ..., nsems-1) */</span></span><br><span class="line">   <span class="type">short</span>           sem_op;   <span class="comment">/* operation (negative, 0, or positive) */</span></span><br><span class="line">   <span class="type">short</span>           sem_flg;  <span class="comment">/* IPC_NOWAIT, SEM_UNDO */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>参数 nops</strong> 指定了数组的长度。</p>
<p><strong>成员属性 sem_op 的取值</strong></p>
<p><img src="Snipaste_2022-12-06_10-46-14.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-06_10-46-34.png" width="100%" height="100%"></p>
<p><strong>exit 时的信号量调整</strong></p>
<p>当进程终止时，占用的经由信号量分配的资源并不会收回。<br>无论何时只要为信号量操作指定了 SEM_UNDO 标志，然后分配资源（sem_op 值小于 0），那么内核就会记住对于该特定信号量，分配给调用进程多少资源（sem_op 的绝对值）。当该进程终止时，内核将检验该进程是否还有尚未处理的信号量调整值。若有，则按调整值对相应信号量值进行处理。</p>
<p>若用带 SETVAL 或 SETALL 命令的 semctl 设置一个信号量的值，则在所有进程中，该信号量的值都将设置为 0.</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/docs/en/i/7.2?topic=ssw_ibm_i_72/apis/unix3a2.html">补充文档</a></p>
<h1 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h1><p>可以使用信号量或记录锁或互斥量来实现多进程对共享存储区的存取。</p>
<p>XSI 共享存储段是内存的匿名段。每个共享存储段使用 shmid_ds 结构来表示（至少包含如下属性）：</p>
<p><img src="Snipaste_2022-12-06_13-49-52.png" width="100%" height="100%"></p>
<p>其中数据类型 shmatt_t 定义为无符号整型，它至少与 unsigned short 一样大。</p>
<hr>
<p><img src="Snipaste_2022-12-06_13-51-31.png" width="100%" height="100%"></p>
<hr>
<table border='1' style='table-layout: fixed;' width='100%'>
    <caption><em>共享存储相关操作函数</em></caption>
    <tbody>
        <tr>
            <th rowspan='1'>函数名称</th>
            <th colspan='3' align='center'>作用</th>
        </tr>
        </th>
        <tr>
            <th align='center'>shmget</th>
            <td align='left' colspan='3'>获取一个共享存储描述符</td>
        </tr>
        <tr>
            <th align='center'>shmctl</th>
            <td align='left' colspan='3'>对共享存储段进行多种操作</td>
        </tr>
        <tr>
            <th align='left'>shmat</th>
            <td align='left' colspan='3'>将共享存储段连接到调用进程的地址空间中</td>
        </tr>
        <tr>
            <th align='left'>shmdt</th>
            <td align='left' colspan='3'>与共享存储段分离。但并不从系统中删除其标识符和相关的数据结构。该标识符仍然存在，直到某个进程（一般是服务器进程）带 IPC_RMID 命令的调用 shmctl 特地删除它为止</td>
        </tr>
    </tbody>
</table>


<p><img src="Snipaste_2022-12-06_13-52-06.png" width="100%" height="100%"></p>
<p>当创建新的共享存储段时，应初始化 shmid_ds 结构的下列成员：</p>
<ul>
<li>ipc_perm 结构</li>
<li>shm_lpid、shm_nattach、shm_atime、shm_dtime 都设置为 0</li>
<li>shm_ctime 设置为当前时间</li>
<li>shm_segsz 设置为请求的 size</li>
</ul>
<p><strong>参数 size</strong> 是该共享存储段的长度，以字节为单位。实现通常将其向上取为系统页长的整数倍。若应用指定的 size 并非系统页长的整数倍，那么最后一页的余下部分是不可使用的。</p>
<p>若正在创建一个新段（通常在服务器进程中），则必须指定其 size；新段内的内容被初始化为 0.<br>若正在引用一个现存的段（一个客户进程），则将 size 指定为 0。</p>
<hr>
<p><img src="Snipaste_2022-12-06_14-11-18.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-06_14-14-49.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_14-16-17.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-06_14-23-01.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-06_14-25-27.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_14-25-53.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-12-06_14-26-42.png" width="100%" height="100%"></p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印一些特定系统存放各种类型的数据的位置信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ARRAY_SIZE	40000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MALLOC_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SHM_SIZE	100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SHM_MODE	0600	<span class="comment">/* user read/write */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>	<span class="built_in">array</span>[ARRAY_SIZE];	<span class="comment">/* uninitialized data = bss */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">shm1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		shmid;</span><br><span class="line">	<span class="type">char</span>	*ptr, *shmptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;array[] from %p to %p\n&quot;</span>, (<span class="type">void</span> *)&amp;<span class="built_in">array</span>[<span class="number">0</span>],</span><br><span class="line">	  (<span class="type">void</span> *)&amp;<span class="built_in">array</span>[ARRAY_SIZE]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;stack around %p\n&quot;</span>, (<span class="type">void</span> *)&amp;shmid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ptr = <span class="built_in">malloc</span>(MALLOC_SIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloced from %p to %p\n&quot;</span>, (<span class="type">void</span> *)ptr,</span><br><span class="line">	  (<span class="type">void</span> *)ptr+MALLOC_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, SHM_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((shmptr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;shared memory attached from %p to %p\n&quot;</span>, (<span class="type">void</span> *)shmptr,</span><br><span class="line">	  (<span class="type">void</span> *)shmptr+SHM_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="Snipaste_2022-12-06_14-51-17.png" width="100%" height="100%"></p>
<p>从上述结果中可以看到该系统的内存布局：<br><img src="Snipaste_2022-12-06_14-52-22.png" width="100%" height="100%"></p>
<hr>
<p><strong>/dev/zero 的存储映射</strong></p>
<blockquote>
<p>在读设备 /dev/zero 时，该设备是 0 字节的无限资源。它接收写向它的任何数据，但又忽略这些数据。<br>/dev/zero 由两个不相关的进程使用。</p>
</blockquote>
<p><strong>/dev/zero 进行存储映射时，具有一些特殊性质：</strong><br><img src="Snipaste_2022-12-06_14-57-27.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 15.33</span></span><br><span class="line"><span class="comment">// 在父子进程之间使用 /dev/zero 的存储映射 IO 的 IPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	NLOOPS		1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SIZE		sizeof(long)	<span class="comment">/* size of shared memory area */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">update</span><span class="params">(<span class="type">long</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>((*ptr)++);	<span class="comment">/* return value before increment */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		fd, i, counter;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line">	<span class="type">void</span>	*area;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((area = mmap(<span class="number">0</span>, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">	  fd, <span class="number">0</span>)) == MAP_FAILED)</span><br><span class="line">		err_sys(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">	close(fd);		<span class="comment">/* can close /dev/zero now that it&#x27;s mapped */</span></span><br><span class="line"></span><br><span class="line">	TELL_WAIT();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;			<span class="comment">/* parent */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOPS; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="type">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">&quot;parent: expected %d, got %d&quot;</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_CHILD(pid);</span><br><span class="line">			WAIT_CHILD();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* child */</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NLOOPS + <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">			WAIT_PARENT();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((counter = update((<span class="type">long</span> *)area)) != i)</span><br><span class="line">				err_quit(<span class="string">&quot;child: expected %d, got %d&quot;</span>, i, counter);</span><br><span class="line"></span><br><span class="line">			TELL_PARENT(getppid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="Snipaste_2022-12-06_15-07-46.png" width="100%" height="100%"></p>
<hr>
<p><strong>匿名存储映射</strong></p>
<p><img src="Snipaste_2022-12-06_15-12-15.png" width="100%" height="100%"></p>
<h1 id="POSIX-信号量"><a href="#POSIX-信号量" class="headerlink" title="POSIX 信号量"></a>POSIX 信号量</h1><p>POSIX 信号量与 XSI 信号量的区别：<br><img src="Snipaste_2022-12-06_15-57-14.png" width="100%" height="100%"></p>
<p>POSIX 信号量有命名的和未命名的两种形式，其差异在于创建和销毁的形式上，其他工作一样。</p>
<ul>
<li>未命名信号量仅能用在同一进程中的线程中，或者不同进程中已经映射相同内存到它们的地址空间中的线程。</li>
<li>命名信号量可以通过名字访问，因此可以被任何已知它们名字的进程中的线程访问</li>
</ul>
<table border='1' style='table-layout: fixed;' width='100%'>
    <caption><em>POSIX 信号量相关操作函数</em></caption>
    <tbody>
        <tr>
            <th colspan='1' align='center'>函数名</th>
            <th colspan='2' align='center'>描述</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_open</th>
            <th colspan='2' align='center'>创建一个新的命名信号量或者使用一个现有信号量</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_close</th>
            <th colspan='2' align='center'>释放信号量的相关资源</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_unlink</th>
            <th colspan='2' align='center'>销毁一个命名信号量。<br><br> 若存在对该信号量的引用，则需要等待最后一个引用关闭次啊可以销毁该命名信号量。 </th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_trywait</th>
            <th colspan='2' rowspan='2' align='center'>实现信号量减 1 操作 <br><br>当信号量值为 0 时，sem_wait 会阻塞直到成功减 1 或被信号打断为止 <br><br> sem_trywait 不会阻塞，而是返回 -1 ，并置 errno 为 EAGAIN</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_wait</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_timedwait</th>
            <th colspan='2' align='center'>减 1 过程中，若不满足条件则阻塞一段时间</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_post</th>
            <th colspan='2' align='center'>实现信号量加 1 的操作。<br><br> 调用 sem_post 时，若在调用 sem_wait（或者 sem_timedwait）中发生进程阻塞，那么进程会被唤醒并且被 sem_post 增 1 的信号量计数回再次被 sem_wait（或者 sem_timedwait）减 1</th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_init</th>
            <th colspan='2' align='center'>创建一个未命名的信号量。 <br><br> 在单个进程中使用 POSIX 信号量时，使用未命名信号量更容易，因为这仅改变创建和销毁信号量的方式 </th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_destroy</th>
            <th colspan='2' align='center'>释放未命名信号量的资源。<br><br> 调用 sem_destroy 后，不能再使用任何带有 sem 的信号量函数，除非通过调用 sem_init 重新初始化它 </th>
        </tr>
        <tr>
            <th colspan='1' align='left'>sem_getvalue</th>
            <th colspan='2' align='center'>检索信号量的值。<br><br> 该函数获取的值后，信号量的值仍旧可能被其他线程更改。除非使用传统的同步机制避免信号量的竞争，否则该函数仅能用于调试过程中。<br> Mac OS X 10.6.8 中不支持该函数。 </th>
        </tr>
    </tbody>
</table>

<p><img src="Snipaste_2022-12-06_17-06-24.png" width="100%" height="100%"></p>
<table border='1' style='table-layout: fixed;' width='100%'>
    <caption><em>用法</em></caption>
    <tbody>
        <tr>
            <th colspan='1' align='center'>用途</th>
            <th colspan='2' align='center'>参数设定</th>
        </tr>
        <tr>
            <th colspan='1' align='center'>使用现有的命名信号量</th>
            <th colspan='2' align='center'>指定信号量名字和 oflag = 0</th>
        </tr>
        </th>
        <tr>
            <th colspan='1' align='center'>创建新的信号量，若信号量已存在，则 sem_open 失败</th>
            <td colspan='2' align='left'>oflag 设定 O_CREAT ｜ O_EXEL 标志；mode 指定信号量访问权限；value 指定信号量的初始值（范围为 0～SEM_VALUE_MAX）；</td>
        </tr>
        <tr>
            <th colspan='1' align='center'>创建新的信号量，若存在则使用存在的信号量</th>
            <td colspan='2' align='left'>与上一条相比，仅需要保留 oflag 的标志为 O_CREAT (待验证)</td>
        </tr>
    </tbody>
</table>

<blockquote>
<p>mode 取值与打开文件的权限位相同：用户读、用户写、用户执行、组读、组写、组执行、其他读、其他写、其他执行。</p>
<p>赋值给信号量的权限可以被调用者的文件创建屏蔽字修改。</p>
</blockquote>
<p><strong>信号量命名规则：</strong></p>
<ul>
<li>名字的第一个字符应该是斜杠 <code>/</code>。</li>
<li>名字不应包含斜杠</li>
<li>名字长度不长于 _POSIX_NAME_MAX 个字符长度。</li>
</ul>
<hr>
<p><img src="Snipaste_2022-12-06_17-47-35.png" width="100%" height="100%"></p>
<p>进程退出前没有调用 sem_close ，内核会自动关闭已打开的信号量。但这并不会影响信号量的状态，即若信号量增 1，内核也不会改变它。即使调用 sem_close ，信号量的值也不会变。</p>
<p>在 POSIX 信号量中没有类似 XSI 信号量的 SEM_UNDO 机制。</p>
<hr>
<p><img src="Snipaste_2022-12-06_17-56-31.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_18-00-42.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_18-04-06.png" width="100%" height="100%"></p>
<p>参数 tsptr 指定的是绝对时间。基于 CLOCK_REALTIME 时钟测算。</p>
<p>若等待超时，则返回 -1 ，并置 errno 为 ETIEMDOUT。</p>
<hr>
<p><img src="Snipaste_2022-12-06_18-08-31.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_18-10-57.png" width="100%" height="100%"></p>
<p><strong>参数 pshared</strong> 指定了该未命名信号量是否用于多进程环境。<br>pshared != 0 表示用于多进程环境，否则不用于。<br><strong>参数 value</strong> 指定该未命名信号量的初始值。</p>
<p><strong>参数 sem</strong> 用来获取创建的未命名信号量的地址。若该未命名信号量用于两个进程中，那么 sem 参数需要指向两个进程之间共享的内存范围。</p>
<hr>
<p><img src="Snipaste_2022-12-06_18-18-57.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-06_18-19-41.png" width="100%" height="100%"></p>
<p>调用成功时，参数 valp 用于存储信号量的值。使用 sem_getvalue 获取的信号量值可能会被其他线程更改。</p>
<p>在 Mac OS X 10.6.8 中是不支持该函数的。</p>
<hr>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slock 可以用于一个线程加锁，另一个线程解锁。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slock</span> &#123;</span></span><br><span class="line">	<span class="type">sem_t</span> *semp;</span><br><span class="line">	<span class="type">char</span>   name[_POSIX_NAME_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于 POSIX 信号量量来实现互斥</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;slock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个竞争线程同时访问 s_alloc 函数时，创建的名字是相同的</span></span><br><span class="line"><span class="keyword">struct</span> slock *</span><br><span class="line"><span class="title function_">s_alloc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slock</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((sp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> slock))) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>(sp-&gt;name, <span class="keyword">sizeof</span>(sp-&gt;name), <span class="string">&quot;/%ld.%d&quot;</span>, (<span class="type">long</span>)getpid(),</span><br><span class="line">		  cnt++);</span><br><span class="line">		<span class="comment">// sem_open 使用 O_EXCL 标志后，只会导致并发的两个线程</span></span><br><span class="line">		<span class="comment">// 一个成功，一个失败并将 errno 置为 EEXIST</span></span><br><span class="line">		sp-&gt;semp = sem_open(sp-&gt;name, O_CREAT|O_EXCL, S_IRWXU, <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> ((sp-&gt;semp == SEM_FAILED) &amp;&amp; (errno == EEXIST));</span><br><span class="line">	<span class="keyword">if</span> (sp-&gt;semp == SEM_FAILED) &#123;</span><br><span class="line">		<span class="built_in">free</span>(sp);</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sem_unlink(sp-&gt;name); <span class="comment">// 销毁名字使得其他进程能够访问它，同时也简化了进程终止后的清理工作。</span></span><br><span class="line">	<span class="keyword">return</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">s_free</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	sem_close(sp-&gt;semp);</span><br><span class="line">	<span class="built_in">free</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_lock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_wait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_trylock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_trywait(sp-&gt;semp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">s_unlock</span><span class="params">(<span class="keyword">struct</span> slock *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>(sem_post(sp-&gt;semp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户进程-服务器进程属性（Client–Server-Properties）"><a href="#客户进程-服务器进程属性（Client–Server-Properties）" class="headerlink" title="客户进程-服务器进程属性（Client–Server Properties）"></a>客户进程-服务器进程属性（Client–Server Properties）</h1><p>不同类型的 IPC 对客户进程和服务器进程的影响：</p>
<ol>
<li><p>客户端进程使用 fork 以及 exec 创建服务端进程。<br>CS 之间通信可以使用两个半双工的管道。服务进程可以是拥有某些特殊权限的 set-user-ID 程序。<br>此外，服务进程能够通过客户进程的实际用户 ID 来确定客户进程的身份。（调用 exec 子进程会继承父进程的实际用户 ID 和实际组 ID）<br>这种方式需要创建 open server，用于专门为客户进程打开（调用 open）文件。这样除了 用户/组/其他 权限的检查外，还可以添加一些额外的检查（如通过设置 ser-user-ID 位）。open server 通过客户进程的实际用户 ID 来决定其是否对请求文件有访问权限。</p>
<p>这种情况下，服务进程作为子进程能够将普通文件的内容传送给客户进程（父进程）但不能用于特殊设备文件的传输。同时服务进程也不可以传递已打开的文件描述符给客户进程，（反之是可以的）。</p>
</li>
<li><p>服务进程以守护进程来运行，并使用某种形式的 IPC 与客户进程通讯<br>不能使用管道，可以使用 FIFO 或者消息队列来实现。<br>服务进程可以看到每个客户进程的 FIFO 以便于返回数据给客户进程。</p>
<p><img src="Snipaste_2022-12-07_11-15-31.png" width="100%" height="100%"></p>
</li>
</ol>
<p>补充材料：原书15.11节</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS">YFS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/">http://jeckfs.gitee.io/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeckfs.gitee.io/JeckFS" target="_blank">JeckFS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/JeckFS/tags/Unix/">Unix</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/"><img class="prev-cover" src="https://img2.baidu.com/it/u=2566230917,2808117782&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unix-网络IPC-Sockets</div></div></a></div><div class="next-post pull-right"><a href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"><img class="next-cover" src="https://img0.baidu.com/it/u=3927742728,83245337&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix-文件和目录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JeckFS/2022/11/22/Unix-%E4%BC%AA%E7%BB%88%E7%AB%AF/" title="Unix-伪终端"><img class="cover" src="https://img1.baidu.com/it/u=2598981474,2305186611&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Unix-伪终端</div></div></a></div><div><a href="/JeckFS/2022/12/01/Unix-%E6%96%87%E4%BB%B6IO/" title="Unix-文件IO"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">Unix-文件IO</div></div></a></div><div><a href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" title="Unix-文件和目录"><img class="cover" src="https://img0.baidu.com/it/u=3927742728,83245337&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">Unix-文件和目录</div></div></a></div><div><a href="/JeckFS/2022/11/15/Unix-%E7%BA%BF%E7%A8%8B/" title="Unix-线程"><img class="cover" src="https://img2.baidu.com/it/u=341242123,757592285&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">Unix-线程</div></div></a></div><div><a href="/JeckFS/2022/11/21/Unix-%E7%BB%88%E7%AB%AFIO/" title="Unix-终端IO"><img class="cover" src="https://img2.baidu.com/it/u=1787475710,2159333383&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Unix-终端IO</div></div></a></div><div><a href="/JeckFS/2022/11/22/Unix-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" title="Unix-守护进程"><img class="cover" src="https://img2.baidu.com/it/u=3747114911,414713113&fm=253&fmt=auto&app=138&f=JPEG?w=882&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Unix-守护进程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/JeckFS/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YFS</div><div class="author-info__description">快乐每一天</div></div><div class="card-info-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">247</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">64</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pipes"><span class="toc-number">1.</span> <span class="toc-text">Pipes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#popen-and-pclose-Functions"><span class="toc-number">2.</span> <span class="toc-text">popen and pclose Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%90%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">协同进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FIFOs"><span class="toc-number">4.</span> <span class="toc-text">FIFOs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XSI-IPC"><span class="toc-number">5.</span> <span class="toc-text">XSI IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Identifiers-and-Keys"><span class="toc-number">5.1.</span> <span class="toc-text">Identifiers and Keys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">权限结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E9%99%90%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">结构限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">5.4.</span> <span class="toc-text">优缺点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XSI-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">7.</span> <span class="toc-text">XSI 信号量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">8.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POSIX-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">POSIX 信号量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E8%BF%9B%E7%A8%8B-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7%EF%BC%88Client%E2%80%93Server-Properties%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">客户进程-服务器进程属性（Client–Server Properties）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点"><img src="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="NAS-SAN异同点"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点">NAS-SAN异同点</a><time datetime="2022-12-12T02:06:26.000Z" title="发表于 2022-12-12 10:06:26">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC"><img src="https://img0.baidu.com/it/u=3927742728,83245337&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-高级IPC"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC">Unix-高级IPC</a><time datetime="2022-12-10T03:55:57.000Z" title="发表于 2022-12-10 11:55:57">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets"><img src="https://img2.baidu.com/it/u=2566230917,2808117782&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-网络IPC-Sockets"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets">Unix-网络IPC-Sockets</a><time datetime="2022-12-07T05:37:59.000Z" title="发表于 2022-12-07 13:37:59">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" title="Unix-进程通讯"><img src="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-进程通讯"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" title="Unix-进程通讯">Unix-进程通讯</a><time datetime="2022-12-03T11:33:28.000Z" title="发表于 2022-12-03 19:33:28">2022-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" title="Unix-文件和目录"><img src="https://img0.baidu.com/it/u=3927742728,83245337&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-文件和目录"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" title="Unix-文件和目录">Unix-文件和目录</a><time datetime="2022-12-02T05:45:15.000Z" title="发表于 2022-12-02 13:45:15">2022-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YFS</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/JeckFS/js/utils.js"></script><script src="/JeckFS/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/JeckFS/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>