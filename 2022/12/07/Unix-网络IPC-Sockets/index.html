<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Unix-网络IPC-Sockets | JeckFS</title><meta name="keywords" content="Unix"><meta name="author" content="YFS"><meta name="copyright" content="YFS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Socket 描述符Socket 描述符就像文件描述符，它是获取 Socket 的一个入口，在 Unix 系统汇总通常它被实现为文件描述符。    Socket 相关操作函数               average        描述                 socket       创建一个 Socket。                       shutdown       禁">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix-网络IPC-Sockets">
<meta property="og:url" content="http://jeckfs.gitee.io/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/index.html">
<meta property="og:site_name" content="JeckFS">
<meta property="og:description" content="Socket 描述符Socket 描述符就像文件描述符，它是获取 Socket 的一个入口，在 Unix 系统汇总通常它被实现为文件描述符。    Socket 相关操作函数               average        描述                 socket       创建一个 Socket。                       shutdown       禁">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=1787475710,2159333383&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800">
<meta property="article:published_time" content="2022-12-07T05:37:59.000Z">
<meta property="article:modified_time" content="2023-01-04T06:05:47.017Z">
<meta property="article:author" content="YFS">
<meta property="article:tag" content="Unix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=1787475710,2159333383&fm=253&fmt=auto&app=120&f=JPEG?w=1280&h=800"><link rel="shortcut icon" href="/JeckFS/img/favicon.png"><link rel="canonical" href="http://jeckfs.gitee.io/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/JeckFS/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/JeckFS/',
  algolia: undefined,
  localSearch: {"path":"/JeckFS/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unix-网络IPC-Sockets',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-04 14:05:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">252</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">66</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1787475710,2159333383&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/JeckFS/">JeckFS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unix-网络IPC-Sockets</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-07T05:37:59.000Z" title="发表于 2022-12-07 13:37:59">2022-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-04T06:05:47.017Z" title="更新于 2023-01-04 14:05:47">2023-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/JeckFS/categories/Unix/">Unix</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unix-网络IPC-Sockets"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Socket-描述符"><a href="#Socket-描述符" class="headerlink" title="Socket 描述符"></a>Socket 描述符</h1><p>Socket 描述符就像文件描述符，它是获取 Socket 的一个入口，在 Unix 系统汇总通常它被实现为文件描述符。</p>
<table border='1' style='table-layout: fixed;' width='100%'>
  <caption><em>Socket 相关操作函数</em></caption>
  <tbody>
    <tr>
      <th colspan='1' align='center'>average </th>
      <th colspan='2' align='center'>描述</th>
    </tr>
    <tr>
      <th colspan='1' align='left'>socket</th>
      <th colspan='2' align='center'>创建一个 Socket。</th>
    </tr>
    </th>
    <tr>
      <th colspan='1' align='center'> shutdown</th>
      <td colspan='2' align='left'>禁用 Socket IO</td>
    </tr>
    <tr>
      <th colspan='1' align='center'></th>
      <td colspan='2' align='left'></td>
    </tr>
    <tr>
      <th colspan='1' align='center'></th>
      <td colspan='2' align='left'></td>
    </tr>
    <tr>
      <th colspan='1' align='center'></th>
      <td colspan='2' align='left'></td>
    </tr>
    <tr>
      <th colspan='1' align='center'></th>
      <td colspan='2' align='left'></td>
    </tr>
    <tr>
      <th colspan='1' align='center'></th>
      <td colspan='2' align='left'></td>
    </tr>
  </tbody>
</table>

<p><img src="Snipaste_2022-12-07_13-45-20.png" width="100%" height="100%"></p>
<p><strong>参数 domain</strong> 确定了地址格式。每种 domain 在表示地址时都有它自己的格式。domain 参数的值域如下：</p>
<p><img src="Snipaste_2022-12-07_13-51-37.png" width="100%" height="100%"></p>
<p>这些常量都以 <code>AF_</code> （address family）开头。</p>
<p>大多数系统用 AF_LOCAL来作为 AF_UNIX 的一个别名。<br>AF_UNSPEC domain 作为一个通配符，用于表示任意一个 domain 。</p>
<p><strong>参数 type</strong> 用于表示 Socket 的类型。取值如下：</p>
<p><img src="Snipaste_2022-12-07_13-55-28.png" width="100%" height="100%"></p>
<p><strong>参数 protocol</strong> 通常为 0，表示对于给定的 domain 和 Socket 类型使用默认的协议。当对于同一个 domain 和  Socket 类型存在多种协议，则参数 protocol 可用于指定其中具体的某个协议。</p>
<p>AF_INET domain 且类型为 SOCK_STREAM 的 socket 的默认协议是 TCP。<br>AF_INET domain 切类型为 SOCK_DGRAM 的 socket 的默认协议是 UDP。</p>
<p>Internet domain socket 的相关协议如下：</p>
<p><img src="Snipaste_2022-12-07_14-01-23.png" width="100%" height="100%"></p>
<p>SOCK_STREAM socket 提供字节流服务。当读端从 SOCK_STREAM socket 中读取时并不一定能读取到写端写入的全部数据，因此需要多次读取才能读取到完整数据。</p>
<p>SOCK_SEQPACKET socket 与 SOCK_STREAM 类似，只不过其提供面向消息的服务。即读端能够读取到写端写入的完整消息。流控制传输协议（Stream Control Transmission Protocol, SCTP）提供了报文按序到达的服务。</p>
<p>SOCK_RAW socket 提供了面向 IP 层的报文传输接口。这时应用需要自己构建协议头。为了阻止恶意程序绕过安全机制创建报文，在创建 raw socket 时需要超级用户权限才可以。</p>
<p>尽管 Socket 描述符实际上是以文件描述符的形式而存在的，但并不是所有的参数为文件描述符的函数都能操作 Socket。下图展示了允许混用的函数：</p>
<p><img src="Snipaste_2022-12-07_14-28-06.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-07_14-49-09.png" width="100%" height="100%"></p>
<table border='1' style='table-layout: fixed;' width='100%'>
  <caption><em>参数 how 的取值</em></caption>
  <tbody>
    <tr>
      <th colspan='1' align='center'>SHUT_RD</th>
      <th colspan='2' align='center'>禁用从 Socket 中读</th>
    </tr>
    <tr>
      <th colspan='1' align='center'>SHUT_WR</th>
      <th colspan='2' align='left'>禁用 Socket 数据传输</th>
    </tr>
    </th>
    <tr>
      <th colspan='1' align='center'>SHUT_RDWR</th>
      <td colspan='2' align='left'>禁用读写 Socket</td>
    </tr>
  </tbody>
</table>

<p>shutdown() 与 close() 的区别：</p>
<ul>
<li>只有关闭最后一个活动引用时，close 才释放网络端点。<br>若复制一个套接字（dup），要直到关闭了最后一个引用它的文件描述符才会释放该套接字。</li>
<li>shutdown 允许使一个套接字处于不活动状态，和引用它的文件描述符数量无关。另外，也可以方便地关闭套接字双向传输的任意一个方向。</li>
</ul>
<h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p><img src="Snipaste_2022-12-07_16-36-06.png" width="100%" height="100%"></p>
<p>大端：最大字节地址出现在最低有效字节（Least Significant Byte， LSB）<br>小端：最低有效字节包含最小字节地址。</p>
<p>无论字节如何排序，最高有效字节（Most Significant Byte，MSB）总是在左边，最低有效字节总是在右边。</p>
<p><img src="Snipaste_2022-12-07_16-42-03.png" width="100%" height="100%"></p>
<p>在同一个机器上通信是不用考虑字节序的，但在异构的主机之间通信则要考虑。因此 TCP/IP 建议使用大端字节序。</p>
<p>在 TCP/IP 中地址使用网络字节序表示，因此需要将网络字节序转换为处理器的字节序。</p>
<p>处理器字节序与网络字节序转换函数：<br><img src="Snipaste_2022-12-07_16-45-43.png" width="100%" height="100%"></p>
<p><code>h</code> 表示主机字节序<br><code>n</code> 表示网络字节序<br><code>l</code> 表示长整数（4字节）<br><code>s</code> 表示短整数（4字节）</p>
<h2 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       inet_ntop - convert IPv4 and IPv6 addresses from binary to text form</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">                             <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       This  function  converts  the  network address structure src in the af address family into a character <span class="built_in">string</span>.</span><br><span class="line">       The resulting <span class="built_in">string</span> is copied to the buffer pointed to by dst, which must be a non-<span class="literal">NULL</span> pointer.  The  caller</span><br><span class="line">       specifies the number of bytes available in this buffer in the argument size.</span><br><span class="line"></span><br><span class="line">       inet_ntop()  extends  the <span class="title function_">inet_ntoa</span><span class="params">(<span class="number">3</span>)</span> function to support multiple address families, <span class="title function_">inet_ntoa</span><span class="params">(<span class="number">3</span>)</span> is now con‐</span><br><span class="line">       sidered to be deprecated in favor of <span class="title function_">inet_ntop</span><span class="params">()</span>.  The following address families are currently supported:</span><br><span class="line"></span><br><span class="line">       AF_INET</span><br><span class="line">              src points to a <span class="keyword">struct</span> <span class="title function_">in_addr</span> <span class="params">(in network byte order)</span> which is converted to an IPv4 network address in</span><br><span class="line">              the  dotted-decimal  format,  &quot;ddd.ddd.ddd.ddd&quot;.  The buffer dst must be at least INET_ADDRSTRLEN bytes</span><br><span class="line">              <span class="type">long</span>.</span><br><span class="line"></span><br><span class="line">       AF_INET6</span><br><span class="line">              src points to a <span class="keyword">struct</span> <span class="title function_">in6_addr</span> <span class="params">(in network byte order)</span> which is converted to a representation of  this</span><br><span class="line">              address  in  the most appropriate IPv6 network address format <span class="keyword">for</span> this address.  The buffer dst must be</span><br><span class="line">              at least INET6_ADDRSTRLEN bytes <span class="type">long</span>.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, <span class="title function_">inet_ntop</span><span class="params">()</span> returns a non-<span class="literal">NULL</span> pointer to dst.  <span class="literal">NULL</span> is returned <span class="keyword">if</span> there was an error, with errno</span><br><span class="line">       <span class="built_in">set</span> to indicate the error.</span><br><span class="line"></span><br><span class="line">ERRORS</span><br><span class="line">       EAFNOSUPPORT</span><br><span class="line">              af was not a valid address family.</span><br><span class="line"></span><br><span class="line">       ENOSPC The converted address <span class="built_in">string</span> would exceed the size given by size.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       inet_pton - convert IPv4 and IPv6 addresses from text to binary form</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       This  function  converts  the  character <span class="built_in">string</span> src into a network address structure in the af address family,</span><br><span class="line">       then copies the network address structure to dst.  The af argument must be either AF_INET or AF_INET6.</span><br><span class="line"></span><br><span class="line">       The following address families are currently supported:</span><br><span class="line"></span><br><span class="line">       AF_INET</span><br><span class="line">              src points to a  character  <span class="built_in">string</span>  containing  an  IPv4  network  address  in  dotted-decimal  format,</span><br><span class="line">              <span class="string">&quot;ddd.ddd.ddd.ddd&quot;</span>,  where  ddd  is  a  decimal number of up to three digits in the range <span class="number">0</span> to <span class="number">255.</span>  The</span><br><span class="line">              address is converted to a <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">and</span> <span class="title">copied</span> <span class="title">to</span> <span class="title">dst</span>, <span class="title">which</span> <span class="title">must</span> <span class="title">be</span>  <span class="title">sizeof</span>(<span class="keyword">struct</span>  <span class="title">in_addr</span>)  (4)</span></span><br><span class="line"><span class="class">              <span class="title">bytes</span> (32 <span class="title">bits</span>) <span class="title">long</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">       <span class="title">AF_INET6</span></span></span><br><span class="line"><span class="class">              <span class="title">src</span>  <span class="title">points</span>  <span class="title">to</span>  <span class="title">a</span>  <span class="title">character</span> <span class="title">string</span> <span class="title">containing</span> <span class="title">an</span> <span class="title">IPv6</span> <span class="title">network</span> <span class="title">address</span>.  <span class="title">The</span> <span class="title">address</span> <span class="title">is</span> <span class="title">converted</span> <span class="title">to</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">              <span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">and</span> <span class="title">copied</span> <span class="title">to</span> <span class="title">dst</span>, <span class="title">which</span> <span class="title">must</span> <span class="title">be</span> <span class="title">sizeof</span>(<span class="keyword">struct</span> <span class="title">in6_addr</span>) (16) <span class="title">bytes</span>  (128  <span class="title">bits</span>)  <span class="title">long</span>.</span></span><br><span class="line"><span class="class">              <span class="title">The</span> <span class="title">allowed</span> <span class="title">formats</span> <span class="title">for</span> <span class="title">IPv6</span> <span class="title">addresses</span> <span class="title">follow</span> <span class="title">these</span> <span class="title">rules</span>:</span></span><br><span class="line"></span><br><span class="line">              <span class="number">1.</span> The  preferred  format is x:x:x:x:x:x:x:x.  This form consists of eight hexadecimal numbers, each of</span><br><span class="line">                 which expresses a <span class="number">16</span>-bit <span class="title function_">value</span> <span class="params">(i.e., each x can be up to <span class="number">4</span> hex digits)</span>.</span><br><span class="line"></span><br><span class="line">              2. A series of contiguous zero values in the preferred format can  be  abbreviated  to  ::.   Only  one</span><br><span class="line">                 instance  of  ::  can occur in an address.  For example, the loopback address 0:0:0:0:0:0:0:1 can be</span><br><span class="line">                 abbreviated as ::1.  The wildcard address, consisting of all zeros, can be written as ::.</span><br><span class="line"></span><br><span class="line">              3. An alternate format is useful <span class="keyword">for</span> expressing IPv4-mapped IPv6 addresses.  This form  is  written  as</span><br><span class="line">                 x:x:x:x:x:x:d.d.d.d,  where  the six leading xs are hexadecimal values that define the six most-sig‐</span><br><span class="line">                 nificant 16-bit pieces of the <span class="title function_">address</span> <span class="params">(i.e., <span class="number">96</span> bits)</span>, and the ds express a value in  dotted-decimal</span><br><span class="line">                 notation  that  defines the least significant 32 bits of the address.  An example of such an address</span><br><span class="line">                 is ::FFFF:204.152.189.116.</span><br><span class="line"></span><br><span class="line">              See RFC 2373 <span class="keyword">for</span> further details on the representation of IPv6 addresses.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       <span class="title function_">inet_pton</span><span class="params">()</span> returns 1 on <span class="title function_">success</span> <span class="params">(network address was successfully converted)</span>.  0 is returned <span class="keyword">if</span> src does  not</span><br><span class="line">       contain  a  character <span class="built_in">string</span> representing a valid network address in the specified address family.  If af does</span><br><span class="line">       not contain a valid address family, -1 is returned and errno is <span class="built_in">set</span> to EAFNOSUPPORT.</span><br></pre></td></tr></table></figure>
<p><code>p</code>: presentation<br><code>n</code>: numeric</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span></span><br><span class="line">       <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr)];</span><br><span class="line">           <span class="type">int</span> domain, s;</span><br><span class="line">           <span class="type">char</span> str[INET6_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">               <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &#123;i4|i6|&lt;num&gt;&#125; string\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           domain = (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;i4&quot;</span>) == <span class="number">0</span>) ? AF_INET :</span><br><span class="line">                    (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;i6&quot;</span>) == <span class="number">0</span>) ? AF_INET6 : atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">           s = inet_pton(domain, argv[<span class="number">2</span>], buf);</span><br><span class="line">           <span class="keyword">if</span> (s &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">                   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Not in presentation format&quot;</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   perror(<span class="string">&quot;inet_pton&quot;</span>);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">               perror(<span class="string">&quot;inet_ntop&quot;</span>);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">           <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">$ ./a.out i6 <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">::</span><br><span class="line">$ ./a.out i6 <span class="number">1</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">8</span></span><br><span class="line"><span class="number">1</span>::<span class="number">8</span></span><br><span class="line">$ ./a.out i6 <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:FFFF:<span class="number">204.152</span><span class="number">.189</span><span class="number">.116</span></span><br><span class="line">::ffff:<span class="number">204.152</span><span class="number">.189</span><span class="number">.116</span></span><br></pre></td></tr></table></figure>
<h2 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h2><p>网络配置信息可以存储在 /etc/hosts 中或者 /etc/services 中或者 DNS 中或者 NIS 中。无论放在何处，都可以用下列函数进行访问。</p>
<p><img src="Snipaste_2022-12-07_17-07-30.png" width="100%" height="100%"></p>
<p>用于查找给定计算机系统的主机信息。</p>
<p>若主机数据库文件没有打开，gethostent 将会打开它。sethostent 会打开文件，若已打开则将读取为止移动到起始位置。若 参数 stayopen 置为非零值，则文件在调用 gethostent 之后仍旧打开。<br>endhostent 可以用来关闭该文件。</p>
<p>gethostent 返回的 hostent 指针指向一个静态数据缓冲区（每次调用 gethostent 都会覆盖该区域）。</p>
<blockquote>
<p>The  sethostent()  function specifies, if stayopen is true (1), that a connected TCP socket should be used for the name server queries and that the connection should remain open during successive queries.  Otherwise, <code>name server queries</code> will use UDP datagrams.<br>The endhostent() function ends the use of a TCP connection for name server queries.</p>
</blockquote>
<p><img src="Snipaste_2022-12-07_17-16-18.png" width="100%" height="100%"></p>
<p>gethostent 返回的 hostent 中的地址格式是网络字节序的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_hostent</span><span class="params">(<span class="keyword">struct</span> hostent *hostent)</span>&#123;</span><br><span class="line">    <span class="type">char</span>                *p;</span><br><span class="line">    <span class="type">int</span>                 i, j;</span><br><span class="line">    <span class="type">int</span>                 ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hostname:\t\t\t%s\n&quot;</span>, hostent-&gt;h_name);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; hostent-&gt;h_aliases[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hostent-&gt;h_aliases[%d]:\t\t%s\n&quot;</span>, i, hostent-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; hostent-&gt;h_addr_list[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hostent-&gt;h_addr_list[%d]:\t&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; hostent-&gt;h_length; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>, hostent-&gt;h_addr_list[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(hostent-&gt;h_addrtype) &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hostent-&gt;h_addrtype:\t\tAF_INET\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AF_INET6:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hostet-&gt;h_addrtype:\t\tAF_INET6\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrecognized addrtype\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_gethostent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>      *<span class="title">hostent</span>;</span></span><br><span class="line"></span><br><span class="line">    hostent = gethostent();</span><br><span class="line">    print_hostent(hostent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">hostname:                       VM<span class="number">-0</span><span class="number">-6</span>-centos</span><br><span class="line">hostent-&gt;h_aliases[<span class="number">0</span>]:          VM<span class="number">-0</span><span class="number">-6</span>-centos</span><br><span class="line">hostent-&gt;h_addr_list[<span class="number">0</span>]:        <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>.</span><br><span class="line">hostent-&gt;h_addrtype:            AF_INET</span><br><span class="line">hostent-&gt;h_addrtype:            <span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p><img src="Snipaste_2022-12-07_17-20-24.png" width="100%" height="100%"></p>
<p>用于从 <code>/etc/networks</code> 获取网络名称和网络编号。</p>
<p><img src="Snipaste_2022-12-07_17-21-32.png" width="100%" height="100%"></p>
<p>所返回的网络编号（n_net）格式是网络字节序的。n_addrtype 可以只能为 AF_INET.</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/networks</span><br><span class="line"><span class="keyword">default</span>		<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">loopback	<span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">link-local	<span class="number">169.254</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p><strong>getnetbyname()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_netent</span><span class="params">(<span class="keyword">struct</span> netent *netent)</span>&#123;</span><br><span class="line">    <span class="type">int</span>         i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(netent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arg is NULL in print_netent()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The official name of the network:\t%s\n&quot;</span>, netent-&gt;n_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The network number in host byte order:\t%u\n&quot;</span>, netent-&gt;n_net);</span><br><span class="line">    <span class="keyword">switch</span>(netent-&gt;n_addrtype) &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The type of the network number:\t\tAF_INET\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AF_INET6:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The type of the network number:\t\tAF_INET6\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrecognized addrtype\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; netent-&gt;n_aliases[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alternative names for the network\t%s\n&quot;</span>, netent-&gt;n_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getnetbyname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netent</span>       *<span class="title">netent</span>;</span></span><br><span class="line"></span><br><span class="line">    netent = getnetbyname(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    print_netent(netent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    netent = getnetbyname(<span class="string">&quot;loopback&quot;</span>);</span><br><span class="line">    print_netent(netent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    netent = getnetbyname(<span class="string">&quot;link-local&quot;</span>);</span><br><span class="line">    print_netent(netent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">The official name of the network:       <span class="keyword">default</span></span><br><span class="line">The network number in host byte order:  <span class="number">0</span></span><br><span class="line">The type of the network number:         AF_INET</span><br><span class="line"></span><br><span class="line">The official name of the network:       loopback</span><br><span class="line">The network number in host byte order:  <span class="number">2130706432</span></span><br><span class="line">The type of the network number:         AF_INET</span><br><span class="line"></span><br><span class="line">The official name of the network:       link-local</span><br><span class="line">The network number in host byte order:  <span class="number">2851995648</span></span><br><span class="line">The type of the network number:         AF_INET</span><br></pre></td></tr></table></figure>
<p><strong>getnetent()</strong></p>
<p><code>getnetent()</code> 读取 <code>/etc/networks</code> 文件中的内容。</p>
<p>The getnetent() function reads the next entry from the networks database and returns a netent st ructure containing the broken-out fields from the entry.  A connection is opened to the database if necessary.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getnetent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netent</span>       *<span class="title">netent</span>;</span></span><br><span class="line"></span><br><span class="line">    netent = getnetent();</span><br><span class="line">    print_netent(netent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    netent = getnetent();</span><br><span class="line">    print_netent(netent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    netent = getnetent();</span><br><span class="line">    print_netent(netent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">The official name of the network:       <span class="keyword">default</span></span><br><span class="line">The network number in host byte order:  <span class="number">0</span></span><br><span class="line">The type of the network number:         AF_INET</span><br><span class="line"></span><br><span class="line">The official name of the network:       loopback</span><br><span class="line">The network number in host byte order:  <span class="number">2130706432</span></span><br><span class="line">The type of the network number:         AF_INET</span><br><span class="line"></span><br><span class="line">The official name of the network:       link-local</span><br><span class="line">The network number in host byte order:  <span class="number">2851995648</span></span><br><span class="line">The type of the network number:         AF_INET</span><br></pre></td></tr></table></figure>
<p><strong>getnetbyaddr()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">test_getnetbyaddr</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netent</span>       *<span class="title">netent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>      <span class="title">in_addr</span>;</span><span class="comment">// inet_pton() 的第三个参数也可以使用 struct in_addr 来获取</span></span><br><span class="line">    <span class="type">char</span>                ip[<span class="number">256</span>], *ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    netent = getnetbyaddr(<span class="number">2851995648</span>, AF_INET);</span><br><span class="line">    print_netent(netent);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(ip, <span class="string">&quot;169.254.0.0&quot;</span>);</span><br><span class="line">    ret = inet_pton(AF_INET, ip, &amp;addr); <span class="comment">// 需要将网络字节序转换为主机字节序</span></span><br><span class="line">    addr = ntohl(addr);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton() error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip = %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_addr = %u\n&quot;</span>, addr);</span><br><span class="line">    netent = getnetbyaddr(addr, AF_INET);</span><br><span class="line">    print_netent(netent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">The official name of the network:       link-local</span><br><span class="line">The network number in host byte order:  <span class="number">2851995648</span></span><br><span class="line">The type of the network number:         AF_INET</span><br><span class="line">ip = <span class="number">169.254</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">in_addr = <span class="number">2851995648</span></span><br><span class="line">The official name of the network:       link-local</span><br><span class="line">The network number in host byte order:  <span class="number">2851995648</span></span><br><span class="line">The type of the network number:         AF_INET</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="Snipaste_2022-12-07_17-28-03.png" width="100%" height="100%"></p>
<p>根据 <code>/etc/protocols</code> 文件，用于协议名称与协议号的相互映射。</p>
<pre><code>   The `getprotoent()` function reads the next entry from the protocols database (see protocols(5)) and returns a protoent structure containing the broken-out fields from the entry.  A connection is opened to the  database
   if necessary.

   The  `getprotobyname()` function returns a protoent structure for the entry from the database that matches the protocol name name.  A connection is opened to the database if necessary.

   The `getprotobynumber()` function returns a protoent structure for the entry from the  database  that  matches the protocol number number.  A connection is opened to the database if necessary.

   The  `setprotoent()`  function opens a connection to the database, and sets the next entry to the first entry. If stayopen is nonzero, then the connection to the database will not be closed between calls to one  of  the getproto*() functions.

   The `endprotoent()` function closes the connection to the database.
</code></pre><p><img src="Snipaste_2022-12-07_17-28-58.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/protocols</span><br><span class="line">ip	<span class="number">0</span>	IP				<span class="meta"># internet protocol, pseudo protocol number</span></span><br><span class="line">hopopt	<span class="number">0</span>	HOPOPT		<span class="meta"># hop-by-hop options for ipv6</span></span><br><span class="line">icmp	<span class="number">1</span>	ICMP		<span class="meta"># internet control message protocol</span></span><br><span class="line">igmp	<span class="number">2</span>	IGMP		<span class="meta"># internet group management protocol</span></span><br><span class="line">ggp		<span class="number">3</span>	GGP			<span class="meta"># gateway-gateway protocol</span></span><br></pre></td></tr></table></figure>
<p><strong>getprotobyname()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_protoent</span><span class="params">(<span class="keyword">struct</span> protoent *protoent)</span> &#123;</span><br><span class="line">    <span class="type">int</span>                 i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(protoent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arg of print_protoent() is NULL\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol name:\t\t\t\t%s\n&quot;</span>, protoent-&gt;p_name);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; protoent-&gt;p_aliases[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alternate protocol name array [%d]:\t%s\n&quot;</span>, i, protoent-&gt;p_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;protocol number:\t\t\t%d\n&quot;</span>, protoent-&gt;p_proto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getprotobyname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protoent</span>         *<span class="title">protoent</span>;</span></span><br><span class="line"></span><br><span class="line">    protoent = getprotobyname(<span class="string">&quot;ip&quot;</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotobyname(<span class="string">&quot;hopopt&quot;</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotobyname(<span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">protocol name:                          ip</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      IP</span><br><span class="line">protocol number:                        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">protocol name:                          hopopt</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      HOPOPT</span><br><span class="line">protocol number:                        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">protocol name:                          icmp</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      ICMP</span><br><span class="line">protocol number:                        <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>getprotobynumber()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">test_getprotobynumber</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protoent</span>         *<span class="title">protoent</span>;</span></span><br><span class="line"></span><br><span class="line">    protoent = getprotobynumber(<span class="number">0</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotobynumber(<span class="number">1</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotobynumber(<span class="number">2</span>);</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">protocol name:                          ip</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      IP</span><br><span class="line">protocol number:                        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">protocol name:                          icmp</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      ICMP</span><br><span class="line">protocol number:                        <span class="number">1</span></span><br><span class="line"></span><br><span class="line">protocol name:                          igmp</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      IGMP</span><br><span class="line">protocol number:                        <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>getprotoent()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">test_getprotoent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protoent</span>         *<span class="title">protoent</span>;</span></span><br><span class="line"></span><br><span class="line">    protoent = getprotoent();</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotoent();</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    protoent = getprotoent();</span><br><span class="line">    print_protoent(protoent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">protocol name:                          ip</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      IP</span><br><span class="line">protocol number:                        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">protocol name:                          hopopt</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      HOPOPT</span><br><span class="line">protocol number:                        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">protocol name:                          icmp</span><br><span class="line">alternate protocol name <span class="built_in">array</span> [<span class="number">0</span>]:      ICMP</span><br><span class="line">protocol number:                        <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p><img src="Snipaste_2022-12-07_17-30-24.png" width="100%" height="100%"></p>
<p>每个服务有一个唯一的端口号来支持</p>
<p>getservbyname：将一个服务名映射到一个端口号；<br>getservbyport：将一个端口号映射到一个服务名；<br>getservent：顺序扫描数服务数据库。</p>
<p>数据源：<code>/etc/services</code></p>
<p>The  <code>getservent()</code>  function  reads the next entry from the services database (see services(5)) and returns a servent structure containing the broken-out fields from the entry.  A connection is opened to  the  database if necessary.</p>
<p>The  <code>getservbyname()</code>  function  returns a servent structure for the entry from the database that matches the service name using protocol proto.  If proto is NULL, any protocol will be matched.  A connection is  opened to the database if necessary.</p>
<p>The  <code>getservbyport()</code>  function  returns a servent structure for the entry from the database that matches the port port (given in network byte order) using protocol proto.  If  proto  is  NULL,  any  protocol  will  be matched.  A connection is opened to the database if necessary.</p>
<p>The  <code>setservent()</code>  function  opens a connection to the database, and sets the next entry to the first entry. If stayopen is nonzero, then the connection to the database will not be closed between calls to one  of  the getserv*() functions.</p>
<p>The <code>endservent()</code> function closes the connection to the database.</p>
<p>servent 结构如下：</p>
<p><img src="Snipaste_2022-12-07_17-32-27.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># service-name  port/protocol  [aliases ...]   [# comment]</span></span><br><span class="line"></span><br><span class="line">tcpmux          <span class="number">1</span>/tcp                           # TCP port service multiplexer</span><br><span class="line">tcpmux          <span class="number">1</span>/udp                           # TCP port service multiplexer</span><br><span class="line">rje             <span class="number">5</span>/tcp                           # Remote Job Entry</span><br><span class="line">rje             <span class="number">5</span>/udp                           # Remote Job Entry</span><br><span class="line">echo            <span class="number">7</span>/tcp</span><br><span class="line">echo            <span class="number">7</span>/udp</span><br><span class="line">discard         <span class="number">9</span>/tcp           sink null</span><br><span class="line">discard         <span class="number">9</span>/udp           sink null</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>getservbyname()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_servent</span><span class="params">(<span class="keyword">struct</span> servent *servent)</span>&#123;</span><br><span class="line">    <span class="type">int</span>         i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(servent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arg of print_servent() is NULL\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;service name:\t\t\t\t\t%s\n&quot;</span>, servent-&gt;s_name);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; servent-&gt;s_aliases[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alternative names for service [%d]:\t\t%s\n&quot;</span>,i, servent-&gt;s_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The service port:\t\t\t\t%d\n&quot;</span>, servent-&gt;s_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The protocol name to use with this service:\t%s\n&quot;</span>, servent-&gt;s_proto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getservbyname</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span>          *<span class="title">servent</span>;</span></span><br><span class="line"></span><br><span class="line">    servent = getservbyname(<span class="string">&quot;tcpmux&quot;</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservbyname(<span class="string">&quot;rje&quot;</span>, <span class="string">&quot;udp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservbyname(<span class="string">&quot;discard&quot;</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">service name:                                   tcpmux</span><br><span class="line">The service port:                               <span class="number">256</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br><span class="line"></span><br><span class="line">service name:                                   rje</span><br><span class="line">The service port:                               <span class="number">1280</span></span><br><span class="line">The protocol name to use with this service:     udp</span><br><span class="line"></span><br><span class="line">service name:                                   discard</span><br><span class="line">Alternative names <span class="keyword">for</span> service [<span class="number">0</span>]:              sink</span><br><span class="line">Alternative names <span class="keyword">for</span> service [<span class="number">1</span>]:              null</span><br><span class="line">The service port:                               <span class="number">2304</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br></pre></td></tr></table></figure>
<p><strong>getservbyport()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getservbyport</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span>          *<span class="title">servent</span>;</span></span><br><span class="line"></span><br><span class="line">    servent = getservbyport(<span class="number">256</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservbyport(<span class="number">1280</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservbyport(<span class="number">2304</span>, <span class="string">&quot;tcp&quot;</span>);</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">service name:                                   tcpmux</span><br><span class="line">The service port:                               <span class="number">256</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br><span class="line"></span><br><span class="line">service name:                                   rje</span><br><span class="line">The service port:                               <span class="number">1280</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br><span class="line"></span><br><span class="line">service name:                                   discard</span><br><span class="line">Alternative names <span class="keyword">for</span> service [<span class="number">0</span>]:              sink</span><br><span class="line">Alternative names <span class="keyword">for</span> service [<span class="number">1</span>]:              null</span><br><span class="line">The service port:                               <span class="number">2304</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br></pre></td></tr></table></figure>
<p><strong>getservent()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_getservent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">servent</span>          *<span class="title">servent</span>;</span></span><br><span class="line"></span><br><span class="line">    servent = getservent();</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservent();</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    servent = getservent();</span><br><span class="line">    print_servent(servent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">service name:                                   tcpmux</span><br><span class="line">The service port:                               <span class="number">256</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br><span class="line"></span><br><span class="line">service name:                                   tcpmux</span><br><span class="line">The service port:                               <span class="number">256</span></span><br><span class="line">The protocol name to use with this service:     udp</span><br><span class="line"></span><br><span class="line">service name:                                   rje</span><br><span class="line">The service port:                               <span class="number">1280</span></span><br><span class="line">The protocol name to use with this service:     tcp</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="Snipaste_2022-12-07_17-35-27.png" width="100%" height="100%"></p>
<p>将一个主机名和一个服务名映射到一个地址。需要提供主机名、服务名，或者两者都提供。若仅提供一个，另外一个必须是空指针。主机名可以是一个节点名或点分格式的主机地址。</p>
<p>getaddrinfo 返回一个链表结构 addrinfo（freeaddrinfo 可以释放该结构）。</p>
<p><img src="Snipaste_2022-12-07_18-05-03.png" width="100%" height="100%"></p>
<p>参数 hint 是一个用于过滤地址的模板，包括 ai_family、ai_flags、ai_protocol、ai_socketype 字段（其余字段必须设置为 0，指针字段必须为空）。</p>
<p>ai_flags 取值如下：<br><img src="Snipaste_2022-12-07_18-07-19.png" width="100%" height="100%"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **res)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *res)</span>; <span class="comment">//用于释放 res 链表。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细见 <code>man getaddinfo</code></p>
</blockquote>
<ul>
<li>参数 node 与 service 分别指定了 host 与 service。getaddrinfo() 通过参数 res 返回一个或多个 addrinfo 结构体（结构体中的数据可以用于 bind() 和 connect() 的参数）。</li>
<li>getaddrinfo() 是可重入函数</li>
<li>参数 hints 指定了所返回的 addrinfo 结构体（参数 res）的选择条件。若参数 hints 不为 NULL，通过 hints 指向的结构体中的 ai_family、ai_socketype、ai_protocol 属性指定了具体的限定条件：<ul>
<li>ai_family        限定了返回的所期望的 address family。值域为：<code>AF_INET、AF_INET6、AF_UNSPEC</code>。AF_UNSPEC 说明 getaddrinfo() 应该返回任何可以与 node 参数、service 参数一起使用的任何 address family 的 Socket addresses（如 IPv4 或 IPv6）</li>
<li>ai_socketype    值域为 <code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code>、0（表明任何类型的 Socket addresses 可被 getaddrinfo() 返回）</li>
<li>ai_protocol        指定了返回的 socket addresses 的协议。取值为 0 表明任何协议的 socket addresses 都可以被 getaddrinfo() 返回。</li>
<li>ai_flags        指定了一些可选项。多个选项值可以通过按位或组合在一起使用。</li>
<li>hints 中其他成员应该设置为 0 或者 NULL。</li>
<li>参数 hints 为 NULL 等价于 hints 指向 ai_socketype = 0，ai_protocol = 0， ai_family = AF_UNSPEC， ai_flags = AI_V4MAPPED | AI_ADDRCONFIG。</li>
</ul>
</li>
<li>参数 node 要么是一个数值形式的网络地址（对于 IPv4，点分十进制形式可以通过 inet_aton() 转换成数值形式；对于 ipv6，十六进制地址可以通过 inet_pton() 转换成数值形式），要么是一个网络 hostname。若 hints.ai_flags 包含 AI_NUMERICHOST 标志，那么参数 node 必须是一个数值形式的网络地址。AI_NUMERICHOST 标志会抑制任何潜在的网络 host 地址的长时间查询。</li>
<li>hints.ai_flags = AI_PASSIVE &amp;&amp; node == NULL 时，所返回的 Socket 地址会包含通配符。这种地址更适合 bind() 一个用于 accept() 连接的 Socket。通常是服务器端的应用使用该通配符地址 accept 连接。若参数 node 不为 NULL，则 AI_PASSIVE 标志将被忽略。</li>
<li>若 hints.ai_flags 中不包含 AI_PASSIVE 标志，所返回的 Socket 地址适合用于 connect()、sendto()、sendmsg() 中。若参数 node == NULL，那么网络地址江北设置为环回地址接口，这种情况用于运行在在同一个主机中的对等实体通信。</li>
<li>参数 service 在每个返回的地址结构体中设置了端口号。若参数 service 是一个 service name（<code>man 5 services</code>）则将被转换成对应的端口号。参数 service 也可以指定为一个整数。若参数 service 为 NULL，则返回的 Socket 地址中的端口号将保持为初始化状态。若 hints.ai_flags 包含 AI_NUMERICSERV 标志，且参数 service 不为 NULL，那么参数 service 必须指向一个包含数值格式的端口号的字符串。在已知不需要的情况下， AI_NUMERICSERV 标志禁止会调用名称解析服务。</li>
<li>参数 node 与参数 service 不能同时为 NULL。</li>
<li>若 hints.ai_flags 包含 AI_CANONNAME 标志，那么所返回的 addrinfo 链表中的首个元素的 ai_canonname 属性将被设置为主机的正式名称（the official name of the host）。</li>
<li>所返回的 addrinfo 结构体中的其他属性按照如下规则初始化：<ul>
<li>ai_family、ai_socktype、ai_protocol 属性返回 Socket 使用 socket() 创建时的参数。ai_family 设置为 AF_INET 或 AF_INET6；ai_socktype 设置为 SOCK_DGRAM 或 SOCK_STREAM；ai_protocol 设置为该 socket 的协议。<blockquote>
<p><code>int socket(int af_domain, int type, int protocol);</code></p>
</blockquote>
</li>
<li>ai_addr 属性设置为 Socket 地址。ai_addrlen 属性设置为 Socket 地址所占的字节长度。</li>
</ul>
</li>
<li>若 hints.ai_flags 包含 AI_ADDRCONFIG 标志，则仅当本地系统至少配置一个 IPv4 地址时参数 res 包含 IPv4 地址；仅当本滴系统配置至少一个 IPv6 地址时，参数 res 包含 IPv6 地址。这种情况下不考虑环回地址。</li>
<li>若参数 hints.ai_flags 包含 AI_V4MAPPED 标志，且 hints.ai_family 为 AF_INET6 ，当没有匹配的 IPv6 地址时参数 res 会存储 IPv4-mapped IPv6 地址。若 hints.ai_flags 包含 AI_V4MAPPED 标志与 AI_ALL 标志，参数 res 会存储 IPv6 与 IPv4-mapped IPv6 地址。若不指定 AI_V4MAPPED 标志，AI_ALL 标志将被忽略。</li>
</ul>
<div class="tabs" id="getaddrinfo()的使用"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#getaddrinfo()的使用-1">服务器端</button></li><li class="tab"><button type="button" data-href="#getaddrinfo()的使用-2">客户端</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="getaddrinfo()的使用-1"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 500</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">result</span>, *<span class="title">rp</span>;</span></span><br><span class="line">    <span class="type">int</span> sfd, s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">peer_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> peer_addr_len;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">/* Allow IPv4 or IPv6 */</span></span><br><span class="line">    hints.ai_socktype = SOCK_DGRAM; <span class="comment">/* Datagram socket */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* For wildcard IP address */</span></span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;          <span class="comment">/* Any protocol */</span></span><br><span class="line">    hints.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">    hints.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">    hints.ai_next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s = getaddrinfo(<span class="literal">NULL</span>, argv[<span class="number">1</span>], &amp;hints, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo: %s\n&quot;</span>, gai_strerror(s));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* getaddrinfo() returns a list of address structures.</span></span><br><span class="line"><span class="comment">       Try each address until we successfully bind(2).</span></span><br><span class="line"><span class="comment">       If socket(2) (or bind(2)) fails, we (close the socket</span></span><br><span class="line"><span class="comment">       and) try the next address. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rp = result; rp != <span class="literal">NULL</span>; rp = rp-&gt;ai_next) &#123;</span><br><span class="line">        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype,</span><br><span class="line">                rp-&gt;ai_protocol);</span><br><span class="line">        <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bind(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;                  <span class="comment">/* Success */</span></span><br><span class="line"></span><br><span class="line">        close(sfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rp == <span class="literal">NULL</span>) &#123;               <span class="comment">/* No address succeeded */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not bind\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(result);           <span class="comment">/* No longer needed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read datagrams and echo them back to sender */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        peer_addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        nread = recvfrom(sfd, buf, BUF_SIZE, <span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr *) &amp;peer_addr, &amp;peer_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;               <span class="comment">/* Ignore failed request */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> host[NI_MAXHOST], service[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">        s = getnameinfo((<span class="keyword">struct</span> sockaddr *) &amp;peer_addr,</span><br><span class="line">                        peer_addr_len, host, NI_MAXHOST,</span><br><span class="line">                        service, NI_MAXSERV, NI_NUMERICSERV);</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received %ld bytes from %s:%s\n&quot;</span>,</span><br><span class="line">                    (<span class="type">long</span>) nread, host, service);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getnameinfo: %s\n&quot;</span>, gai_strerror(s));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sendto(sfd, buf, nread, <span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">struct</span> sockaddr *) &amp;peer_addr,</span><br><span class="line">                    peer_addr_len) != nread)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error sending response\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="getaddrinfo()的使用-2"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 500</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">result</span>, *<span class="title">rp</span>;</span></span><br><span class="line">    <span class="type">int</span> sfd, s, j;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s host port msg...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Obtain address(es) matching host/port */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">/* Allow IPv4 or IPv6 */</span></span><br><span class="line">    hints.ai_socktype = SOCK_DGRAM; <span class="comment">/* Datagram socket */</span></span><br><span class="line">    hints.ai_flags = <span class="number">0</span>;</span><br><span class="line">    hints.ai_protocol = <span class="number">0</span>;          <span class="comment">/* Any protocol */</span></span><br><span class="line"></span><br><span class="line">    s = getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;hints, &amp;result);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo: %s\n&quot;</span>, gai_strerror(s));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* getaddrinfo() returns a list of address structures.</span></span><br><span class="line"><span class="comment">       Try each address until we successfully connect(2).</span></span><br><span class="line"><span class="comment">       If socket(2) (or connect(2)) fails, we (close the socket</span></span><br><span class="line"><span class="comment">       and) try the next address. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (rp = result; rp != <span class="literal">NULL</span>; rp = rp-&gt;ai_next) &#123;</span><br><span class="line">        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype,</span><br><span class="line">                     rp-&gt;ai_protocol);</span><br><span class="line">        <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connect(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;                  <span class="comment">/* Success */</span></span><br><span class="line"></span><br><span class="line">        close(sfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rp == <span class="literal">NULL</span>) &#123;               <span class="comment">/* No address succeeded */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not connect\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(result);           <span class="comment">/* No longer needed */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send remaining command-line arguments as separate</span></span><br><span class="line"><span class="comment">       datagrams, and read responses from server */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(argv[j]) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* +1 for terminating null byte */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len + <span class="number">1</span> &gt; BUF_SIZE) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                    <span class="string">&quot;Ignoring long message in argument %d\n&quot;</span>, j);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(sfd, argv[j], len) != len) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;partial/failed write\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nread = read(sfd, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received %ld bytes: %s\n&quot;</span>, (<span class="type">long</span>) nread, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<hr>
<p><img src="Snipaste_2022-12-07_18-08-44.png" width="100%" height="100%"></p>
<p>getaddrinfo 调用失败时，gai_strerror 用于将返回的错误码转换成错误消息。</p>
<hr>
<p><img src="Snipaste_2022-12-07_18-10-03.png" width="100%" height="100%"></p>
<p>用于将一个地址转换成一个主机名和一个服务名。</p>
<p>参数 addr 用于存储转换后的主机名和服务名。若 host 为空，则指向一个长度为 hostlen 字节的缓冲区用于存放返回的主机名。若 service 为空，则指向一个长度为 servlen 字节的缓冲区用于存放返回的服务名。</p>
<p>参数 flags 用于控制转换的方式，值域如下：</p>
<p><img src="Snipaste_2022-12-07_18-13-24.png" width="100%" height="100%"></p>
<hr>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SOLARIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_family</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; family &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_family) &#123;</span><br><span class="line">	<span class="keyword">case</span> AF_INET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;inet&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_INET6:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;inet6&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNIX:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unix&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_UNSPEC:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unspecified&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_type</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; type &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_socktype) &#123;</span><br><span class="line">	<span class="keyword">case</span> SOCK_STREAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;stream&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_DGRAM:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;datagram&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_SEQPACKET:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;seqpacket&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SOCK_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;raw&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown (%d)&quot;</span>, aip-&gt;ai_socktype);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_protocol</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; protocol &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (aip-&gt;ai_protocol) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;TCP&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;UDP&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_RAW:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;raw&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown (%d)&quot;</span>, aip-&gt;ai_protocol);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_flags</span><span class="params">(<span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;flags&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (aip-&gt;ai_flags == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; 0&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_PASSIVE)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; passive&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_CANONNAME)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; canon&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICHOST)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; numhost&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_NUMERICSERV)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; numserv&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_V4MAPPED)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; v4mapped&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_flags &amp; AI_ALL)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; all&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	*<span class="title">sinp</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> 			*addr;</span><br><span class="line">	<span class="type">int</span> 				err;</span><br><span class="line">	<span class="type">char</span> 				abuf[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: %s nodename service&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_family = <span class="number">0</span>;</span><br><span class="line">	hint.ai_socktype = <span class="number">0</span>;</span><br><span class="line">	hint.ai_protocol = <span class="number">0</span>;</span><br><span class="line">	hint.ai_addrlen = <span class="number">0</span>;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		print_flags(aip);</span><br><span class="line">		print_family(aip);</span><br><span class="line">		print_type(aip);</span><br><span class="line">		print_protocol(aip);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\thost %s&quot;</span>, aip-&gt;ai_canonname?aip-&gt;ai_canonname:<span class="string">&quot;-&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (aip-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">			sinp = (<span class="keyword">struct</span> sockaddr_in *)aip-&gt;ai_addr;</span><br><span class="line">			addr = inet_ntop(AF_INET, &amp;sinp-&gt;sin_addr, abuf,</span><br><span class="line">			    INET_ADDRSTRLEN);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; address %s&quot;</span>, addr?addr:<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; port %d&quot;</span>, ntohs(sinp-&gt;sin_port));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">$ ./a.out harry nfs</span><br><span class="line">flags canon family inet type stream protocol TCP</span><br><span class="line">        host harry address <span class="number">192.168</span><span class="number">.1</span><span class="number">.99</span> port <span class="number">2049</span></span><br><span class="line">flags canon family inet type datagram protocol UDP</span><br><span class="line">        host harry address <span class="number">192.168</span><span class="number">.1</span><span class="number">.99</span> port <span class="number">2049</span></span><br></pre></td></tr></table></figure>
<h1 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h1><p>服务器端应该关联一个地址以便于客户端找到它并请求它。客户端也应采取一种机制来发现这个地址，简单的办法是服务器端保留该地址并将该地址注册在 /etc/service 中或某个名字服务中。</p>
<p><img src="Snipaste_2022-12-07_18-30-25.png" width="100%" height="100%"></p>
<p>用于关联地址和套接字。</p>
<p><img src="Snipaste_2022-12-07_18-31-50.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-07_18-33-49.png" width="100%" height="100%"></p>
<p>用于发现绑定到套接字上的地址。</p>
<p><img src="Snipaste_2022-12-07_18-36-26.png" width="100%" height="100%"></p>
<hr>
<p><img src="Snipaste_2022-12-07_18-36-43.png" width="100%" height="100%"></p>
<p>若套接字已经和对等放连接，可以调用 getpeername 来找到对方的地址。除了返回对等方的地址，函数 getpeername 和 getsocketname 一样。</p>
<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><p><img src="Snipaste_2022-12-08_10-14-47.png" width="100%" height="100%"></p>
<p>在面向连接的网络服务（SOCK_STREAM 或 SOCK_SEQPACKET）交换数据之前，应在服务器与客户端之间通过 connect 函数建立连接。</p>
<p>若 Socket 描述符以非阻塞模式打开，当 connect 失败时会返回 -1 并置 errno 为 EINPROGRESS。当成功调用时，可以使用 poll 或者 select 来监听哪些描述符可写。</p>
<p>无连接服务（SOCK_DGRAM）也可以使用 connect。这时，目的地址是在调用 connect 的时候指定的，后续再次发送报文时不用每次都指定地址。此外，仅能从指定的地址接受报文。</p>
<p>参数 sockfd 用于指定服务器地址，若不指定 connect 绑定默认地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.10</span></span><br><span class="line"><span class="comment">// connect 函数在调用时若发生错误可以重试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数采用指数会退算法（exponential backoff algorithm）</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> numsec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (connect(sockfd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.10 并不能移植到 FreeBSD 中运行。因为 FreeBSD 在</span></span><br><span class="line"><span class="comment">// connect 失败后，对于同一个 socket 的后续 connect 仍旧是失败的。</span></span><br><span class="line"><span class="comment">// 本算法为了可移植，当 connect 失败后，关闭该 socket 并重新创建一个新的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> numsec, fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to connect with exponential backoff.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt;= MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((fd = socket(domain, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (connect(fd, addr, alen) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Connection accepted.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span>(fd);</span><br><span class="line">		&#125;</span><br><span class="line">		close(fd);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Delay before trying again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (numsec &lt;= MAXSLEEP/<span class="number">2</span>)</span><br><span class="line">			sleep(numsec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="Snipaste_2022-12-08_10-44-33.png" width="100%" height="100%"></p>
<p>用于接受连接请求。</p>
<p>参数 backlog 用来推荐系统采用的值（等待队列中未完成的连接请求数量）。实际值由系统决定，上限值为 SOMAXCONN （sys/socket.h）.<br>一旦队列满，就会拒绝接下来的连接请求。</p>
<hr>
<p><img src="Snipaste_2022-12-08_10-55-31.png" width="100%" height="100%"></p>
<p>accept 返回与调用 connect 后的客户端完成连接的 Socket 描述符。该描述符与原来的 socket（sockfd）拥有相同的 Socket 类型和地址族。区别是原来的 socket （参数 sockfd）并不与连接相关联，仅用来接受接下来的连接请求。</p>
<p>若不关心客户端的身份，可以将参数 addr 和 len 置为 NULL。否则，应在调用 accept 之前，将 addr 指向一个能够存储地址的足够大的缓冲区，len 用于指明缓冲区的字节长度。当 accept 返回时，addr 参数存储客户端地址，len 反应了地址的字节长度。</p>
<p>若没有未完成的连接，accept 将会阻塞直到有连接到达。也可以使用 poll 或者 select 来等待连接请求的到达。这种情况下，等待连接请求的 Socket 会以可读的方式出现。</p>
<p>若参数 sockfd 是非阻塞模式的，accept 将会返回 -1 并置 errno 为 EAGAIN 或者 EWOULDBLOCK。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.12 Initialize a socket endpoint for use by a server</span></span><br><span class="line"><span class="comment">// 本算法存在些许问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">initserver</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> qlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, addr, alen) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">if</span> (type == SOCK_STREAM || type == SOCK_SEQPACKET) &#123;</span><br><span class="line">		<span class="keyword">if</span> (listen(fd, qlen) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>当 datagram socket 使用默认对等地址连接时，可以使用 read 和 write 函数进行数据的发送与读取。在本地系统中，读写的都是本地文件，这样可以将 socket 描述符传递给子进程，子进程就可以独立于该 Socket 进行处理。</p>
<p>使用 read 和 write 的一个缺点是：无法指定选项、从多个客户端接收报文、发送带外数据。</p>
<hr>
<p><img src="Snipaste_2022-12-08_11-37-36.png" width="100%" height="100%"></p>
<p>send 允许在发送数据时指定一些标志，该标志可以控制传输的数据如何被处理。<br>对于无连接的 Socket，除非是首次调用 connect 时设置了目的地址，否则不能调用 send 发送数据。</p>
<p>参数 buf 及 nbytes 类似于 write 函数中的对应参数。<br>参数 flag 的取值如下所示：</p>
<p><img src="Snipaste_2022-12-08_11-42-19.png" width="100%" height="100%"></p>
<p>send 调用成功并不表示另一端已经成功接收数据，而是表示数据已经无错误地递送到网络驱动中。</p>
<p>当 send 发送的数据量超过协议所支持的最大值则会返回失败并置 errno 为 EMSGSIZE。对于面向字节流的协议，send 将会阻塞直到全部的数据被传输完成。</p>
<hr>
<p><img src="Snipaste_2022-12-08_11-50-26.png" width="100%" height="100%"></p>
<p>sendto 与 send 的不同之处在于 sendto 允许指定无连接 Socket 的目的地址。<br>对于面向连接的 Socket，目的地址将被忽略（目的地址是隐含在连接中的，不需 sendto 指定）。</p>
<hr>
<p><img src="Snipaste_2022-12-08_15-22-03.png" width="100%" height="100%"></p>
<p>发送一个 msghdr 结构的信息，该结构可以指定多种数据缓冲区（类似于 writev 函数）。</p>
<p>msghdr 结构至少包含一下属性：<br><img src="Snipaste_2022-12-08_15-23-51.png" width="100%" height="100%"></p>
<blockquote>
<p><code>struct iovec</code> 结构参见 readv() writev() 函数那一节。</p>
</blockquote>
<hr>
<p><img src="Snipaste_2022-12-08_15-26-18.png" width="100%" height="100%"></p>
<p>recv 函数类似于 read 函数，不同之处在于 recv 函数可以指定一些选项来控制如何接收数据。</p>
<p>参数 flags 的取值如下：<br><img src="Snipaste_2022-12-08_15-28-06.png" width="100%" height="100%"></p>
<blockquote>
<p>MSG_PEEK 标志的作用是获取下一次读取的数据，但不消费它，即下一次读取时返回的还是 peek 的数据。</p>
</blockquote>
<p>对于 SOCK_STREAM Socket，我们接收到的数据可能少于请求的数据。MSG_WAITALL 标志继承了此特性，它会阻止 recv 函数返回直到所有的请求数据都完成接收为止。<br>对于 SOCK_DGRAM 和 SOCK_SEQPACKET Socket，MSG_WAITALL 标志并无什么影响，因为这些基于消息的 Socket 类型会在一次读取过程中返回整个消息。</p>
<p>当发送方结束数据传输时，若发送方调用的是 shutdown 函数，或者该网络协议默认支持有序的关闭且发送方已经关闭了该 Socket，那么当 recv 接收到所有数据后将会返回 0。</p>
<hr>
<p><img src="Snipaste_2022-12-08_15-40-25.png" width="100%" height="100%"></p>
<p>该函数可以获取发送方的地址。若参数 addr 不为 NULL，将会存储发送方的地址。调用该函数前，应该将 addrlen 指向一个整型指针（值为 addr 指向的Socket 缓冲区的字节长度），函数返回时该指针的内存将变为发送方地址的实际字节长度。</p>
<p>由于能够识别发送方，因此经常用于无连接的 Socket 中。除此之外，recvfrom 与 recv 相同。</p>
<hr>
<p><img src="Snipaste_2022-12-08_15-48-05.png" width="100%" height="100%"></p>
<p><strong>函数说明</strong></p>
<ul>
<li>类似于 readv 可以将接受的数据存储在多个不同的缓冲区中</li>
<li>接收辅助数据</li>
</ul>
<p><strong>参数说明</strong></p>
<p>参数 msg 是用于接收数据的缓冲区。<br>参数 flags 可以控制 recvmsg 的接收数据的行为。</p>
<p>返回时， msghdr 结构中的 msg_flags 属性指明了接收的数据的特征。</p>
<p>recvmsg 返回时 msg_flags 可能的取值如下：<br><img src="Snipaste_2022-12-08_15-56-12.png" width="100%" height="100%"></p>
<hr>
<p><strong>面向连接的客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.16 Client command to get uptime from server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN		128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">connect_retry</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *,</span></span><br><span class="line"><span class="params">	<span class="type">socklen_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_uptime</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于使用 SOCK_STREAM socket，并不能保证一次就能将所有数据都接收，</span></span><br><span class="line">  <span class="comment">// 只能重复调用 recv 知道其返回为 0 为止</span></span><br><span class="line">	<span class="keyword">while</span> ((n = recv(sockfd, buf, BUFLEN, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">		write(STDOUT_FILENO, buf, n);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptime hostname&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 若服务端支持多网络接口或多网络协议，getaddrinfo 将会返回多个候选地址</span></span><br><span class="line">  <span class="comment">// 依次尝试连接每个候选地址，直到找到允许连接到相应服务的为止。</span></span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = connect_retry(aip-&gt;ai_family, SOCK_STREAM, <span class="number">0</span>,</span><br><span class="line">		  aip-&gt;ai_addr, aip-&gt;ai_addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err_exit(err, <span class="string">&quot;can&#x27;t connect to %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面向连接的服务端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.17 Server program to provide system uptime</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN	128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QLEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POSIX.1 规定主机名的长度最大至少255字节（不包括最后的 NULL 字符）</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HOST_NAME_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NAME_MAX 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">initserver</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		clfd;</span><br><span class="line">	FILE	*fp;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	set_cloexec(sockfd);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((clfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: accept error: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		set_cloexec(clfd);</span><br><span class="line">		<span class="keyword">if</span> ((fp = popen(<span class="string">&quot;/usr/bin/uptime&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">			send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (fgets(buf, BUFLEN, fp) != <span class="literal">NULL</span>)</span><br><span class="line">				send(clfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">			pclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">		close(clfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err, n;</span><br><span class="line">	<span class="type">char</span>			*host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptimed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; <span class="number">0</span>)</span><br><span class="line">		n = HOST_NAME_MAX;	<span class="comment">/* best guess */</span></span><br><span class="line">	<span class="keyword">if</span> ((host = <span class="built_in">malloc</span>(n)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, n) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;gethostname error&quot;</span>);</span><br><span class="line">	daemonize(<span class="string">&quot;ruptimed&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 通过调用 gethostname 获取 host （主机名），并搜寻</span></span><br><span class="line">  <span class="comment">// 远程 uptime 服务。getaddinfo 将会返回多个地址，这里</span></span><br><span class="line">  <span class="comment">// 进简单地选择第一个用来建立被动的 Socket 端点（即仅使</span></span><br><span class="line">  <span class="comment">// 用一个监听连接请求）</span></span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(host, <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;ruptimed: getaddrinfo error: %s&quot;</span>,</span><br><span class="line">		  gai_strerror(err));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">    <span class="comment">// initserver 用于初始化一个 socket 用于等待连接请求的到达。</span></span><br><span class="line">    <span class="comment">// 代码见 Figure 16.22</span></span><br><span class="line">		<span class="keyword">if</span> ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr,</span><br><span class="line">		  aip-&gt;ai_addrlen, QLEN)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			serve(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面向连接的服务端 2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.18 Server program illustrating command writing directly to socket</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QLEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HOST_NAME_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NAME_MAX 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">initserver</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与使用 popen 运行 uptime 命令并从连接到命令的标准输出的管道中读取不同，</span></span><br><span class="line"><span class="comment">// 这里使用 fork 创建一个子进程，并使用 dup2 将子进程的 STDIN_FILENO </span></span><br><span class="line"><span class="comment">// 的副本指向 /dev/null，STDOUT_FILENO 及 STDERR_FILENO 指向 Socket。</span></span><br><span class="line"><span class="comment">// 当执行 uptime 时，命令的结果将被写入到标准输出（该输出是连接到 socket</span></span><br><span class="line"><span class="comment">// 的），数据被送回 ruptime 客户端命令。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		clfd, status;</span><br><span class="line">	<span class="type">pid_t</span>	pid;</span><br><span class="line"></span><br><span class="line">	set_cloexec(sockfd);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((clfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: accept error: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: fork error: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;	<span class="comment">/* child */</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The parent called daemonize (&#123;Prog daemoninit&#125;), so</span></span><br><span class="line"><span class="comment">			 * STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO</span></span><br><span class="line"><span class="comment">			 * are already open to /dev/null.  Thus, the call to</span></span><br><span class="line"><span class="comment">			 * close doesn&#x27;t need to be protected by checks that</span></span><br><span class="line"><span class="comment">			 * clfd isn&#x27;t already equal to one of these values.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (dup2(clfd, STDOUT_FILENO) != STDOUT_FILENO ||</span><br><span class="line">			  dup2(clfd, STDERR_FILENO) != STDERR_FILENO) &#123;</span><br><span class="line">				syslog(LOG_ERR, <span class="string">&quot;ruptimed: unexpected error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			close(clfd);</span><br><span class="line">			execl(<span class="string">&quot;/usr/bin/uptime&quot;</span>, <span class="string">&quot;uptime&quot;</span>, (<span class="type">char</span> *)<span class="number">0</span>);</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: unexpected return from exec: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;		<span class="comment">/* parent */</span></span><br><span class="line">			close(clfd); <span class="comment">// 父进程关闭该套接字描述符，因为子进程会继承该套接字描述符</span></span><br><span class="line">      <span class="comment">// 防止子进程变为僵尸进程。使用 wait 只有在子进程处理完当前请求后，</span></span><br><span class="line">      <span class="comment">// 才能接受下一个请求。因为子进程仅用来执行一个 uptime 命令，耗时</span></span><br><span class="line">      <span class="comment">// 很短，因此可以忍受其执行的时间。当子进程很耗时时，不能这么做。</span></span><br><span class="line">			waitpid(pid, &amp;status, <span class="number">0</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err, n;</span><br><span class="line">	<span class="type">char</span>			*host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptimed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; <span class="number">0</span>)</span><br><span class="line">		n = HOST_NAME_MAX;	<span class="comment">/* best guess */</span></span><br><span class="line">	<span class="keyword">if</span> ((host = <span class="built_in">malloc</span>(n)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, n) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;gethostname error&quot;</span>);</span><br><span class="line">	daemonize(<span class="string">&quot;ruptimed&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(host, <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;ruptimed: getaddrinfo error: %s&quot;</span>,</span><br><span class="line">		  gai_strerror(err));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = initserver(SOCK_STREAM, aip-&gt;ai_addr,</span><br><span class="line">		  aip-&gt;ai_addrlen, QLEN)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			serve(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>示例：无连接客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.19 Client command using datagram service</span></span><br><span class="line"><span class="comment">// 使用 datagram socket 的 uptime 客户端命令实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN		128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMEOUT		20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若服务端没有运行，客户端在调用 recvfrom 后会无限期阻塞，因此需要在 recvfrom </span></span><br><span class="line"><span class="comment">// 调用之前设置一个 alarm clock 避免无限期阻塞。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sigalrm</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_uptime</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> addrinfo *aip)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line">	<span class="type">char</span>	buf[BUFLEN];</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 在面向连接的协议中，在交换数据之前需要连接到服务端，连接请求的到达足够表</span></span><br><span class="line">  <span class="comment">// 明其（服务端）需要给客户端提供服务。但对于面向无连接的协议来说，需要有一</span></span><br><span class="line">  <span class="comment">// 种机制来通知服务端提供服务。本例中，客户端想服务端发送 1 字节的消息。服</span></span><br><span class="line">  <span class="comment">// 务端接收后从报文中获取到客户端的地址，然后服务端通过该地址来传送响应信息</span></span><br><span class="line">  <span class="comment">// 。若服务端提供多种服务，可以用这 1 字节的消息来指明客户端需要的服务。</span></span><br><span class="line">	<span class="keyword">if</span> (sendto(sockfd, buf, <span class="number">1</span>, <span class="number">0</span>, aip-&gt;ai_addr, aip-&gt;ai_addrlen) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">	alarm(TIMEOUT);</span><br><span class="line">	<span class="keyword">if</span> ((n = recvfrom(sockfd, buf, BUFLEN, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">			alarm(<span class="number">0</span>);</span><br><span class="line">		err_sys(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	alarm(<span class="number">0</span>);</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>		<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>					sockfd, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>	<span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptime hostname&quot;</span>);</span><br><span class="line">	sa.sa_handler = sigalrm;</span><br><span class="line">	sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">	<span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_socktype = SOCK_DGRAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(argv[<span class="number">1</span>], <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;getaddrinfo error: %s&quot;</span>, gai_strerror(err));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = socket(aip-&gt;ai_family, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			err = errno;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			print_uptime(sockfd, aip);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t contact %s: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(err));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：无连接的服务端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">set_cloexec</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((val = fcntl(fd, F_GETFD, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	val |= FD_CLOEXEC;		<span class="comment">/* enable close-on-exec */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(fcntl(fd, F_SETFD, val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Figure 16.20</span></span><br><span class="line"><span class="comment">// Server providing system uptime over datagrams</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFLEN		128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXADDRLEN	256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HOST_NAME_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NAME_MAX 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">initserver</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *, <span class="type">socklen_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">serve</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				n;</span><br><span class="line">	<span class="type">socklen_t</span>		alen;</span><br><span class="line">	FILE			*fp;</span><br><span class="line">	<span class="type">char</span>			buf[BUFLEN];</span><br><span class="line">	<span class="type">char</span>			abuf[MAXADDRLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>	*<span class="title">addr</span> =</span> (<span class="keyword">struct</span> sockaddr *)abuf;</span><br><span class="line"></span><br><span class="line">	set_cloexec(sockfd);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		alen = MAXADDRLEN;</span><br><span class="line">    <span class="comment">// recvfrom 阻塞直到一个请求到达。请求到达后获取该请求的原地址</span></span><br><span class="line">		<span class="keyword">if</span> ((n = recvfrom(sockfd, buf, BUFLEN, <span class="number">0</span>, addr, &amp;alen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			syslog(LOG_ERR, <span class="string">&quot;ruptimed: recvfrom error: %s&quot;</span>,</span><br><span class="line">			  strerror(errno));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((fp = popen(<span class="string">&quot;/usr/bin/uptime&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">			sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, addr, alen);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (fgets(buf, BUFLEN, fp) != <span class="literal">NULL</span>)</span><br><span class="line">				sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, addr, alen);</span><br><span class="line">			pclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	*<span class="title">ailist</span>, *<span class="title">aip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>	<span class="title">hint</span>;</span></span><br><span class="line">	<span class="type">int</span>				sockfd, err, n;</span><br><span class="line">	<span class="type">char</span>			*host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;usage: ruptimed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((n = sysconf(_SC_HOST_NAME_MAX)) &lt; <span class="number">0</span>)</span><br><span class="line">		n = HOST_NAME_MAX;	<span class="comment">/* best guess */</span></span><br><span class="line">	<span class="keyword">if</span> ((host = <span class="built_in">malloc</span>(n)) == <span class="literal">NULL</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, n) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;gethostname error&quot;</span>);</span><br><span class="line">	daemonize(<span class="string">&quot;ruptimed&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;hint, <span class="number">0</span>, <span class="keyword">sizeof</span>(hint));</span><br><span class="line">	hint.ai_flags = AI_CANONNAME;</span><br><span class="line">	hint.ai_socktype = SOCK_DGRAM;</span><br><span class="line">	hint.ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">	hint.ai_next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ((err = getaddrinfo(host, <span class="string">&quot;ruptime&quot;</span>, &amp;hint, &amp;ailist)) != <span class="number">0</span>) &#123;</span><br><span class="line">		syslog(LOG_ERR, <span class="string">&quot;ruptimed: getaddrinfo error: %s&quot;</span>,</span><br><span class="line">		  gai_strerror(err));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (aip = ailist; aip != <span class="literal">NULL</span>; aip = aip-&gt;ai_next) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((sockfd = initserver(SOCK_DGRAM, aip-&gt;ai_addr,</span><br><span class="line">		  aip-&gt;ai_addrlen, <span class="number">0</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			serve(sockfd);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Socket-选项"><a href="#Socket-选项" class="headerlink" title="Socket 选项"></a>Socket 选项</h1><p><strong>Socket 选项的类型</strong></p>
<ul>
<li>所有 socket 类型都支持的 <strong>通用选型</strong></li>
<li>依赖于底层协议支持的，在 Socket 层次所管理的选项</li>
<li>协议特有选项（每种协议都不同）</li>
</ul>
<p><img src="Snipaste_2022-12-09_12-28-30.png" width="100%" height="100%"></p>
<p><strong>参数 level</strong> 指定了选项可以应用的协议。若选项是通用 socket 层次的选项，level 的值为 SOL_SOCKET；否则，level 置为控制该选项的协议编号。如对于 TCP 选项，level 为 IPPROTO_TCP，对于 IP 选项，level 为 IPPROTP_IP。</p>
<p><img src="Snipaste_2022-12-09_13-06-32.png" width="100%" height="100%"></p>
<p><strong>参数 val</strong> 指向一个数据结构或者一个整数，这取决于选项。一些选项是可开可关的。若整数值非零，则该选项开启，否则关闭。</p>
<p><strong>参数 len</strong> 指定了参数 val 指向的对象的大小。</p>
<hr>
<p><img src="Snipaste_2022-12-09_13-16-42.png" width="100%" height="100%"></p>
<p>在调用 getsockopt 前， <strong>参数 lenp</strong> 置为用来存储选项副本的缓冲区的大小。若缓冲区存不下该选项，则选项将被截断。若缓冲区存的下，则参数 lenp 更新为选项值实际的大小。</p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure 16.22</span></span><br><span class="line"><span class="comment">// Initialize a socket endpoint for use by a server with address reuse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当服务器终止时，该函数会调用失败，这时需要立即重启服务器。正常情况下，TCP 在实现上不允许绑定同一个地址除非超时（通常会有几分钟超时时间）。这时可以使用 SO_REUSEADDR 这个 socket 选项绕过这项限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">initserver</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> alen,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> qlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd, err;</span><br><span class="line">	<span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fd = socket(addr-&gt;sa_family, type, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse,</span><br><span class="line">	  <span class="keyword">sizeof</span>(<span class="type">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">if</span> (bind(fd, addr, alen) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">if</span> (type == SOCK_STREAM || type == SOCK_SEQPACKET)</span><br><span class="line">		<span class="keyword">if</span> (listen(fd, qlen) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">	<span class="keyword">return</span>(fd);</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	err = errno;</span><br><span class="line">	close(fd);</span><br><span class="line">	errno = err;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="带外数据-out-of-band-data"><a href="#带外数据-out-of-band-data" class="headerlink" title="带外数据 (out-of-band data)"></a>带外数据 (out-of-band data)</h1><ul>
<li>只有部分通讯协议支持带外数据。带外数据允许高优先级数据优先等待传送的普通数据递送之前递送。</li>
<li>TCP 支持 out-of-band 数据，而 UDP 不支持。</li>
<li>在 TCP 中，out-of-band 数据又被称为 urgent 数据。TCP 支持发送 1 字节的紧急数据。</li>
<li>使用三种发送函数时指定 MSG_OOB 标志即可产生紧急数据。</li>
<li>若发送的紧急数据不止 1 字节，那么只有该数据的最后一个字节被当作紧急数据。</li>
<li>若 Socket 已经设置了信号生成，当紧急数据到达时，当前程序会发送 SIGURG 信号。</li>
<li>fcntl 函数的 F_SETOWN 命令可以设置 Socket 的所有权。fcntl 的第三个参数为正，表示指定的是进程 ID；若为负（-1 除外），表示进程组 ID。<ul>
<li>通过执行 <code>fcntl(sockfd, F_SETOWN, pid)</code>     进程可以从 socket 中接收信号。</li>
<li>执行 <code>owner = fcntl(sockfd, F_GETOWN, 0)</code>： 若 owner 为正数，则 owner 表示进程 ID（该进程已经完成从 socket 中接收信号的配置）。若 owner 为负数，则 owner 的绝对值表示进程组 ID（该进程组已经完成从 socket 中接收信号的配置）（F_GETOWN 命令可以用来获取当前 Socket 的所有权。）</li>
</ul>
</li>
<li>TCP 支持紧急标志 (urgent mark) 的概念，即紧急数据在普通数据流中的位置。若 SO_OOBINLINE Socket 选项标志，则程序可以从普通数据流中接收紧急数据。可以使用 socketatmark 函数来判断 urgent mark 是否到达。</li>
</ul>
<p><img src="Snipaste_2022-12-09_17-32-04.png" width="100%" height="100%"></p>
<p>当读取的下一个字节是紧急标志所在位置，sockatmark 函数将会返回 1。</p>
<p>当带外数据达到 Socket 的待读队列时，select 函数会将文件描述符以 异常条件挂起(exception condition pending) 的方式返回。<br>可以选择以普通数据方式接收紧急数据；也可以在 recv 函数中设置 MSG_OOB 标志，先于普通数据接收。<br>TCP 队列中仅允许有一个字节的紧急数据。当另一个紧急数据到达时，当前队列的紧急数据将被丢弃。</p>
<h1 id="非阻塞-IO-及异步-IO"><a href="#非阻塞-IO-及异步-IO" class="headerlink" title="非阻塞 IO 及异步 IO"></a>非阻塞 IO 及异步 IO</h1><p>通常，recv 函数在无待接收数据时将会阻塞；send 函数也类似，当 socket 的输出队列中没有足够的空间发送消息时也会阻塞。<br>在非阻塞模式下，recv 和 send 函数会直接失败并将 errno 置为 EWOULDBLOCK 或 EAGAIN，而不是阻塞。这时，可以使用 poll 或者 select 来决定什么时候可以接收或发送数据。</p>
<p>基于 Socket 的异步 IO 的实现思路：当从 Socket 中读取到数据时或当 Socket 的写入队列有可用空间时，触发 SIGIO 信号。<br>具体方法如下：</p>
<ol>
<li>建立 Socket 的所有权，使得信号能够递送到正确的进程<ul>
<li>实现方式一：Use the F_SETOWN command with fcntl.</li>
<li>实现方式二：Use the FIOSETOWN command with ioctl.</li>
<li>实现方式三：Use the SIOCSPGRP command with ioctl.</li>
</ul>
</li>
<li>当 IO 操作不阻塞时，通知 Socket 发送信号<ul>
<li>实现方式一：Use the F_SETFL command with fcntl and enable the O_ASYNC file flag.</li>
<li>实现方式二：Use the FIOASYNC command with ioctl.</li>
</ul>
</li>
</ol>
<p>上述实现机制在不同平台的支持程度：<br><img src="Snipaste_2022-12-09_19-38-38.png" width="100%" height="100%"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS">YFS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/">http://jeckfs.gitee.io/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeckfs.gitee.io/JeckFS" target="_blank">JeckFS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/JeckFS/tags/Unix/">Unix</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=1787475710,2159333383&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/"><img class="prev-cover" src="https://img1.baidu.com/it/u=2656997690,163773951&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unix-高级IPC</div></div></a></div><div class="next-post pull-right"><a href="/JeckFS/2022/12/03/Unix-%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/"><img class="next-cover" src="https://img0.baidu.com/it/u=1955391644,3428991101&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=700&amp;h=466" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix-进程通讯</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JeckFS/2023/01/17/Unix-ioctl%E5%87%BD%E6%95%B0/" title="Unix-ioctl函数"><img class="cover" src="https://img0.baidu.com/it/u=297071526,3870034878&fm=253&fmt=auto&app=138&f=JPEG?w=499&h=332" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-17</div><div class="title">Unix-ioctl函数</div></div></a></div><div><a href="/JeckFS/2022/12/01/Unix-%E6%96%87%E4%BB%B6IO/" title="Unix-文件IO"><img class="cover" src="https://img2.baidu.com/it/u=2566230917,2808117782&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">Unix-文件IO</div></div></a></div><div><a href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试"><img class="cover" src="https://img1.baidu.com/it/u=2322041376,2548191196&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-29</div><div class="title">gdb-调试</div></div></a></div><div><a href="/JeckFS/2022/11/22/Unix-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" title="Unix-守护进程"><img class="cover" src="https://img1.baidu.com/it/u=2860717797,2343059675&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Unix-守护进程</div></div></a></div><div><a href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" title="Unix-文件和目录"><img class="cover" src="https://img1.baidu.com/it/u=2656997690,163773951&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">Unix-文件和目录</div></div></a></div><div><a href="/JeckFS/2022/11/15/Unix-%E7%BA%BF%E7%A8%8B/" title="Unix-线程"><img class="cover" src="https://img1.baidu.com/it/u=2598981474,2305186611&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">Unix-线程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/JeckFS/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YFS</div><div class="author-info__description">快乐每一天</div></div><div class="card-info-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">252</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">66</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket-%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">Socket 描述符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">地址格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.3.</span> <span class="toc-text">地址查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94"><span class="toc-number">3.</span> <span class="toc-text">将套接字与地址关联</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">5.</span> <span class="toc-text">数据传输</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket-%E9%80%89%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">Socket 选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE-out-of-band-data"><span class="toc-number">7.</span> <span class="toc-text">带外数据 (out-of-band data)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-IO-%E5%8F%8A%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">8.</span> <span class="toc-text">非阻塞 IO 及异步 IO</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2023/01/17/Unix-ioctl%E5%87%BD%E6%95%B0/" title="Unix-ioctl函数"><img src="https://img0.baidu.com/it/u=297071526,3870034878&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=499&amp;h=332" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-ioctl函数"/></a><div class="content"><a class="title" href="/JeckFS/2023/01/17/Unix-ioctl%E5%87%BD%E6%95%B0/" title="Unix-ioctl函数">Unix-ioctl函数</a><time datetime="2023-01-17T06:25:45.000Z" title="发表于 2023-01-17 14:25:45">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2023/01/17/finance-%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/" title="finance-银行业务"><img src="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="finance-银行业务"/></a><div class="content"><a class="title" href="/JeckFS/2023/01/17/finance-%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1/" title="finance-银行业务">finance-银行业务</a><time datetime="2023-01-17T01:09:10.000Z" title="发表于 2023-01-17 09:09:10">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2023/01/13/finance-%E6%8E%88%E4%BF%A1/" title="finance-授信"><img src="https://img2.baidu.com/it/u=48958987,1702342987&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="finance-授信"/></a><div class="content"><a class="title" href="/JeckFS/2023/01/13/finance-%E6%8E%88%E4%BF%A1/" title="finance-授信">finance-授信</a><time datetime="2023-01-13T03:09:09.000Z" title="发表于 2023-01-13 11:09:09">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试"><img src="https://img1.baidu.com/it/u=2322041376,2548191196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="gdb-调试"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试">gdb-调试</a><time datetime="2022-12-29T03:33:44.000Z" title="发表于 2022-12-29 11:33:44">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="vim-使用技巧"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧">vim-使用技巧</a><time datetime="2022-12-23T04:09:28.000Z" title="发表于 2022-12-23 12:09:28">2022-12-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YFS</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/JeckFS/js/utils.js"></script><script src="/JeckFS/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/JeckFS/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>