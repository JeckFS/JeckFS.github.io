<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Unix-线程控制 | JeckFS</title><meta name="keywords" content="Unix"><meta name="author" content="YFS"><meta name="copyright" content="YFS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程限制  线程属性 pthread_attr_destroy() 可以逆初始化 pthread_attr_init() 。调用 pthread_attr_destroy 函数后的属性对象再次使用将会导致 pthread_create 函数返回错误码。 线程属性：  每个属性都有一个获取属性值和设置属性值的 get &#x2F; set 方法。这里以 detachstate 属性为例：  detachsta">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix-线程控制">
<meta property="og:url" content="http://jeckfs.gitee.io/JeckFS/2022/11/17/Unix-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="JeckFS">
<meta property="og:description" content="线程限制  线程属性 pthread_attr_destroy() 可以逆初始化 pthread_attr_init() 。调用 pthread_attr_destroy 函数后的属性对象再次使用将会导致 pthread_create 函数返回错误码。 线程属性：  每个属性都有一个获取属性值和设置属性值的 get &#x2F; set 方法。这里以 detachstate 属性为例：  detachsta">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=3747114911,414713113&fm=253&fmt=auto&app=138&f=JPEG?w=882&h=500">
<meta property="article:published_time" content="2022-11-17T07:00:31.000Z">
<meta property="article:modified_time" content="2022-12-15T14:21:46.956Z">
<meta property="article:author" content="YFS">
<meta property="article:tag" content="Unix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=3747114911,414713113&fm=253&fmt=auto&app=138&f=JPEG?w=882&h=500"><link rel="shortcut icon" href="/JeckFS/img/favicon.png"><link rel="canonical" href="http://jeckfs.gitee.io/JeckFS/2022/11/17/Unix-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/JeckFS/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/JeckFS/',
  algolia: undefined,
  localSearch: {"path":"/JeckFS/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unix-线程控制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-15 22:21:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">249</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=3747114911,414713113&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=882&amp;h=500')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/JeckFS/">JeckFS</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unix-线程控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-17T07:00:31.000Z" title="发表于 2022-11-17 15:00:31">2022-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-15T14:21:46.956Z" title="更新于 2022-12-15 22:21:46">2022-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/JeckFS/categories/Unix/">Unix</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unix-线程控制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h1><p><img src="Snipaste_2022-11-17_15-30-36.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-17_15-31-28.png" width="100%" height="100%"></p>
<h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><p><img src="Snipaste_2022-11-17_15-53-52.png" width="100%" height="100%"></p>
<p>pthread_attr_destroy() 可以逆初始化 pthread_attr_init() 。<br>调用 pthread_attr_destroy 函数后的属性对象再次使用将会导致 pthread_create 函数返回错误码。</p>
<p><strong>线程属性：</strong></p>
<p><img src="Snipaste_2022-11-17_15-56-39.png" width="100%" height="100%"></p>
<p>每个属性都有一个获取属性值和设置属性值的 get / set 方法。这里以 detachstate 属性为例：</p>
<p><img src="Snipaste_2022-11-17_15-59-03.png" width="100%" height="100%"></p>
<p>detachstate 参数值域如下。具体取值取决于给定 pthread_attr_t 结构中的属性值。</p>
<ul>
<li>PTHREAD_CREATE_DETACHED</li>
<li>PTHREAD_CREATE_JOINABLE</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">makethread</span><span class="params">(<span class="type">void</span> *(*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line">	<span class="type">pthread_t</span>		tid;</span><br><span class="line">	<span class="type">pthread_attr_t</span>	attr;</span><br><span class="line"></span><br><span class="line">	err = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对线程属性结构清理的唯一接口是 pthread_attr_destroy() ，若 pthread_attr_destroy 函数调用失败，将很难清理线程属性结构。若 pthread_attr_init 函数已经分配内存，可能造成内存泄漏。</p>
<p><strong>线程栈属性</strong></p>
<ul>
<li>编译阶段可以使用 _POSIX_THREAD_ATTR_STACKADDR 或 _POSIX_THREAD_ATTR_STACKSIZE 检测系统是否支持每个线程栈属性。</li>
<li>运行阶段使用 sysconf 函数测试 _SC_THREAD_ATTR_STACKADDR 或 _SC_THREAD_ATTR_STACKSIZE </li>
</ul>
<hr>
<p><img src="Snipaste_2022-11-17_16-36-56.png" width="100%" height="100%"></p>
<p>对于进程来说，虚地址空间的大小是固定的。多个线程共用进程的虚地址空间。因此，当线程调用的函数嵌套很深，则需要的栈大小就可能比默认的大。当那个线程栈的虚地址空间用尽，可使用 malloc 或 mmap 为可替代的栈分配空间，并用 pthread_attr_setstack 函数来改变新建线程的栈位置。</p>
<p>由 stackaddr 参数指定的地址用作线程栈的内存范围中的最低可寻址地址（并不一定是栈的开始位置，若栈是从高地址向低地址方向增长的，那么 stackaddr 线程属性将是栈的结尾位置）。</p>
<p><img src="Snipaste_2022-11-17_17-00-12.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>改变线程栈大小（由系统分配栈空间）。</p>
<p><strong>参数说明：</strong></p>
<p>stacksize 不能小于 PTHREAD_STACK_MIN。</p>
<hr>
<p><img src="Snipaste_2022-11-17_17-04-22.png" width="100%" height="100%"></p>
<p>guardsize 用于说明栈末尾的警戒缓冲大小。常用值是系统页大小的整数倍（通常是 1 倍）。</p>
<p>若线程的栈指针溢出到警戒区域，应用程序可能通过信号接收到出错信息。</p>
<p>若修改了线程属性 stackaddr ，栈警戒缓冲区机制无效（等同于将 guardsize 线程属性设置为 0）。</p>
<h1 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h1><h2 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h2><p>存储结构：pthread_mutexattr_t 结构。</p>
<p><img src="Snipaste_2022-11-17_20-02-50.png" width="100%" height="100%"></p>
<p>互斥量属性包含：</p>
<ol>
<li>进程共享属性（可选）</li>
</ol>
<p>支持检测：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">检测阶段</th>
<th style="text-align:center">检测方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编译阶段</td>
<td style="text-align:center">_POSIX_THREAD_PROCESS_SHARED</td>
</tr>
<tr>
<td style="text-align:center">运行阶段</td>
<td style="text-align:center">sysconf(_SC_THREAD_PROCESS_SHARED)</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>进程共享机制：多个进程共享同一内存区域中的互斥量（需将进程共享互斥量属性设置为 PTHREAD_PROCESS_SHARED）<br>多个线程同步需要将进程共享互斥量属性设置为 PTHREAD_PROCESS_PRIVATE</p>
</blockquote>
<p><strong>进程共享互斥量属性的存取</strong></p>
<p><img src="Snipaste_2022-11-17_20-12-14.png" width="100%" height="100%"></p>
<ol>
<li>互斥量健壮属性</li>
</ol>
<p><img src="Snipaste_2022-11-17_21-03-47.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>用于获取或设置互斥量健壮属性。</p>
<p>健壮性属性值域：</p>
<ul>
<li>PTHREAD_MUTEX_STALLED<br>持有互斥量的进程终止时不需要采取特别的动作。使用互斥量后的行为是未定义的，等待该互斥量解锁的应用程序会被有效地“拖住”。</li>
<li>PTHREAD_MUTEX_ROBUST<br>该值将导致线程调用 pthread_mutex_lock 获取锁。若该锁被另一个进程持有，此时线程会阻塞，并从 pthread_mutex_lock 返回 EOWNERDEAD。</li>
</ul>
<p>在对互斥量进行解锁时，需调用 pthread_mutex_consistent() 来恢复该锁的一致性，否则不可以直接调用 pthread_mutex_unlock() 且该锁不再可用，且其他试图获取该互斥量的阻塞线程就会得到 ENOTRECOVERABLE 错误码。</p>
<ol>
<li>类型属性</li>
</ol>
<p>类型互斥量属性控制着互斥量的锁定特定。POSIX.1 定义了 4 中类型：</p>
<p><img src="Snipaste_2022-11-17_21-17-37.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-17_21-21-31.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-17_21-22-16.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-17_21-22-34.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>获取 / 修改互斥量类型属性。</p>
<p>递归互斥量的一个应用：使用线程在未来某个时间运行某个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">makethread</span><span class="params">(<span class="type">void</span> *(*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line">	<span class="type">pthread_t</span>		tid;</span><br><span class="line">	<span class="type">pthread_attr_t</span>	attr;</span><br><span class="line"></span><br><span class="line">	err = pthread_attr_init(&amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>(err);</span><br><span class="line">	err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">to_info</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>	      (*to_fn)(<span class="type">void</span> *);	<span class="comment">/* function */</span></span><br><span class="line">	<span class="type">void</span>           *to_arg;			<span class="comment">/* argument */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">to_wait</span>;</span>		<span class="comment">/* time to wait */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTONSEC  1000000000	<span class="comment">/* seconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CLOCK_REALTIME) || defined(BSD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clock_nanosleep(ID, FL, REQ, REM)	nanosleep((REQ), (REM))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLOCK_REALTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_REALTIME 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USECTONSEC 1000		<span class="comment">/* microseconds to nanoseconds */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clock_gettime</span><span class="params">(<span class="type">int</span> id, <span class="keyword">struct</span> timespec *tsp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	tsp-&gt;tv_sec = tv.tv_sec;</span><br><span class="line">	tsp-&gt;tv_nsec = tv.tv_usec * USECTONSEC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">timeout_helper</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line"></span><br><span class="line">	tip = (<span class="keyword">struct</span> to_info *)arg;</span><br><span class="line">	clock_nanosleep(CLOCK_REALTIME, <span class="number">0</span>, &amp;tip-&gt;to_wait, <span class="literal">NULL</span>);</span><br><span class="line">	(*tip-&gt;to_fn)(tip-&gt;to_arg);</span><br><span class="line">	<span class="built_in">free</span>(arg);</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timeout</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *when, <span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">now</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">to_info</span>	*<span class="title">tip</span>;</span></span><br><span class="line">	<span class="type">int</span>				err;</span><br><span class="line"></span><br><span class="line">	clock_gettime(CLOCK_REALTIME, &amp;now);</span><br><span class="line">	<span class="keyword">if</span> ((when-&gt;tv_sec &gt; now.tv_sec) ||</span><br><span class="line">	  (when-&gt;tv_sec == now.tv_sec &amp;&amp; when-&gt;tv_nsec &gt; now.tv_nsec)) &#123;</span><br><span class="line">		tip = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> to_info));</span><br><span class="line">		<span class="keyword">if</span> (tip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			tip-&gt;to_fn = func;</span><br><span class="line">			tip-&gt;to_arg = arg;</span><br><span class="line">			tip-&gt;to_wait.tv_sec = when-&gt;tv_sec - now.tv_sec;</span><br><span class="line">			<span class="keyword">if</span> (when-&gt;tv_nsec &gt;= now.tv_nsec) &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = when-&gt;tv_nsec - now.tv_nsec;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tip-&gt;to_wait.tv_sec--;</span><br><span class="line">				tip-&gt;to_wait.tv_nsec = SECTONSEC - now.tv_nsec +</span><br><span class="line">				  when-&gt;tv_nsec;</span><br><span class="line">			&#125;</span><br><span class="line">			err = makethread(timeout_helper, (<span class="type">void</span> *)tip);</span><br><span class="line">			<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">free</span>(tip);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We get here if (a) when &lt;= now, or (b) malloc fails, or</span></span><br><span class="line"><span class="comment">	 * (c) we can&#x27;t make a thread, so we just call the function now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	(*func)(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">retry</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 这里的互斥量 mutex 是递归的，否则会导致死锁</span></span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;function retry executing\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* perform retry steps ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">recursive_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>				err, condition = <span class="number">1</span>, arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>	<span class="title">when</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_init(&amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;pthread_mutexattr_init failed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutexattr_settype(&amp;attr,</span><br><span class="line">	  PTHREAD_MUTEX_RECURSIVE)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t set recursive type&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_init(&amp;mutex, &amp;attr)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t create recursive mutex&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check the condition under the protection of a lock to</span></span><br><span class="line"><span class="comment">	 * make the check and the call to timeout atomic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (condition) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Calculate the absolute time when we want to retry.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		clock_gettime(CLOCK_REALTIME, &amp;when);</span><br><span class="line">		when.tv_sec += <span class="number">10</span>;	<span class="comment">/* 10 seconds from now */</span></span><br><span class="line">		timeout(&amp;when, retry, (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)arg));</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* continue processing ... */</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// 10 sec 后输出：function retry executing</span></span><br><span class="line"><span class="comment">// 20 sec 后进程退出</span></span><br></pre></td></tr></table></figure>
<h2 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h2><p>读写锁属性 pthread_rwlockattr_t 的初始化与反初始化：</p>
<p><img src="Snipaste_2022-11-19_10-12-01.png" width="100%" height="100%"></p>
<p>读写锁的唯一属性是：进程共享属性（与互斥量的进程共享属性相同）。</p>
<p>读写锁的进程共享属性的读取与设置：</p>
<p><img src="Snipaste_2022-11-19_10-14-34.png" width="100%" height="100%"></p>
<h2 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h2><blockquote>
<p>更多条件变量的操作函数参见 《Unix-线程》线程同步小节。</p>
</blockquote>
<p>条件变量属性 pthread_condattr_t 包含 <strong>进程共享属性和时钟属性</strong>。进程共享属性控制着条件变量是被单进程的多个线程使用，还是被多进程的线程使用。</p>
<p>条件变量属性的初始化与反初始化：</p>
<p><img src="Snipaste_2022-11-19_10-17-41.png" width="100%" height="100%"></p>
<p>进程共享属性的获取和设置：</p>
<p><img src="Snipaste_2022-11-19_10-19-42.png" width="100%" height="100%"></p>
<p>时钟属性控制计算 pthread_cond_timedwait 函数的超时参数（tsptr）时采用的是哪个时钟。合法取值如下：</p>
<p><img src="Snipaste_2022-11-19_10-43-36.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-19_10-42-09.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong></p>
<ul>
<li>pthread_condattr_getclock() 获取可被用于 pthread_cond_timedwait 函数的时钟 ID。</li>
<li>pthread_condattr_setclock() 对时钟 ID 进行修改。</li>
</ul>
<h2 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h2><p>屏障属性的初始化与反初始化：</p>
<p><img src="Snipaste_2022-11-19_10-57-48.png" width="100%" height="100%"></p>
<p>目前屏障属性只有 <strong>进程共享属性</strong>，它控制着屏障是被多进程的线程使用，还是只被初始化屏障的进程内的多线程使用。<br>进程共享属性的取值：</p>
<ul>
<li>PTHREAD_PROCESS_SHARED：多进程中的多个线程使用</li>
<li>PTHREAD_PROCESS_PRIVATE：只有初始化屏障的那个进程内的多个线程可用</li>
</ul>
<p>屏障属性的获取或设置进程共享属性的函数：</p>
<p><img src="Snipaste_2022-11-19_11-00-35.png" width="100%" height="100%"></p>
<h1 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h1><blockquote>
<p><strong>线程安全：</strong> 同一个函数在相同时间点被多个线程安全地调用。<br><strong>异步信号安全：</strong> 同一个异步信号处理程序在相同时间被多个线程安全地调用。<br>线程安全并不代表一步信号安全。</p>
</blockquote>
<p>异步信号安全函数如下：</p>
<p><img src="Snipaste_2022-11-19_14-51-21.png" width="100%" height="100%"></p>
<p>不能保证线程安全的函数如下（除此之外的函数都是线程安全的）：</p>
<p><img src="Snipaste_2022-11-19_14-37-16.png" width="100%" height="100%"></p>
<p>图 12-10 中结尾的 _r 表示版本的函数是可重入的。</p>
<p><strong>验证操作系统是否支持线程安全函数：</strong></p>
<ul>
<li>编译阶段使用 _POSIX_THREAD_SAFE_FUNCTIONS (位于 unistd.h) 验证。</li>
<li>运行阶段使用 sysconf(_SC_THREAD_SAFE_FUNCTIONS) 验证。</li>
</ul>
<p>【补充】：<br>很多函数并不是线程安全的，原因是它们返回的数据存放在 <strong>静态的内存缓冲区</strong> 中。将缓冲区变为用户自己提供的可使函数变为线程安全。如：</p>
<ul>
<li>ctermid() 和 tmpnam() 在参数传入空指针时不保证其是线程安全的。</li>
<li>若参数 mbstate_t 传入的是空指针，也不能保证 wcrtomb() 与 wcsrtombs() 是线程安全的。</li>
</ul>
<p><strong>以线程安全的方式管理 FILE 对象：</strong></p>
<p><img src="Snipaste_2022-11-19_15-00-37.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>获取给定 FILE 对象关联的锁（可重入）。<br>在处理多个 FILE 对象时应注意获取锁的顺序，以避免死锁。</p>
<p><img src="Snipaste_2022-11-19_15-05-56.png" width="100%" height="100%"></p>
<p>考虑到一个字符加解锁一次的性能浪费，基于字符的标准 IO 例程不获取锁。<br>在多线程环境下，应被 flockfile 或 ftrylockfile 与 funlockfile 包围。一旦对 FILE 对象加锁，就可以在释放锁之前对这些函数进行多次线程安全地调用。</p>
<div class="tabs" id="getenv"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#getenv-1">线程不安全版本</button></li><li class="tab"><button type="button" data-href="#getenv-2">线程安全版本</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="getenv-1"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRINGSZ	4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> envbuf[MAXSTRINGSZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, len;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRINGSZ<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">return</span>(envbuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getenv 返回的字符串存储在同一个静态存储区中，所不是线程安全的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="getenv-2"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"></span><br><span class="line">	pthread_mutexattr_init(&amp;attr);</span><br><span class="line">	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">	pthread_mutex_init(&amp;env_mutex, &amp;attr);</span><br><span class="line">	pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getenv_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *buf, <span class="type">int</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, len, olen;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			olen = <span class="built_in">strlen</span>(&amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (olen &gt;= buflen) &#123;</span><br><span class="line">				pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">				<span class="keyword">return</span>(ENOSPC);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">strcpy</span>(buf, &amp;environ[i][len+<span class="number">1</span>]);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(ENOENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线实现 getenv_r 线程安全的措施：</p>
<ul>
<li>pthread_once() 确保每个进程只调用 thread_init() 一次。</li>
<li>每个线程传入自己的缓冲区避免了多线程之间的竞争。</li>
<li>使用锁将 getenv_r 与 putenv 串行化。</li>
</ul>
<p>即使 genenv_r 是线程安全的，但并不意味着它对信号处理程序是可重入的。原因是：若信号处理程序在线程执行 getenv_r 时中断了该线程，这是已经占有加锁的 env_mutex 了，这样其他线程试图对这个互斥量的加锁都会被阻塞，最终导致线程进入死锁状态。<br>pthread 函数并不保证是异步信号安全的，所以不能将 pthread 函数用于其他函数，让该函数成为异步信号安全的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h1 id="线程特定数据-线程私有数据"><a href="#线程特定数据-线程私有数据" class="headerlink" title="线程特定数据 / 线程私有数据"></a>线程特定数据 / 线程私有数据</h1><p>线程私有数据 <strong>一般</strong> 只有本线程访问，而不需要担心与其他线程的同步访问问题。</p>
<p><strong>1. 创建与私有数据相关联的键</strong></p>
<p><img src="Snipaste_2022-11-19_15-49-28.png" width="100%" height="100%"></p>
<p>该键用于获取对线程特定数据的访问。创建的键存储在参数 keyp 指向的内存单元中，它可被进程中的所有线程使用。但每个线程把这个键与不同的线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值。</p>
<mark class="hl-label default">确保分配键的代码不会调用多次。</mark> 
<p>destructor 参数指定了与该键关联的析构函数。作用是：若数据地址不为空，则清理该数据。</p>
<p>destructor 函数调用时机：</p>
<ul>
<li>当这个线程退出时（如调用 pthread_exit 或者线程执行返回正常退出），且数据地址被置为非空值</li>
<li>线程取消时，最后的清理处理程序返回之后调用该函数</li>
<li>线程调用 exit、_exit、_Exit、abort 或者其他非正常退出时，不会调用该析构函数。</li>
</ul>
<p>关于键与数据需要注意的地方：</p>
<ol>
<li>线程特定数据通常使用 malloc 分配内存。析构函数通常释放已分配内存。若线程在没有释放内存之前退出，会造成内存泄漏。</li>
<li>线程可为线程特定数据分配多个键。每个键的析构函数可以互不相同也可以相同。键的分配数量受 PTHREAD_KEYS_MAX 限制。</li>
<li>析构函数可能创建新的线程特定数据并与当前的键关联。因此，系统在释放线程特定数据时采用的方法是：当所有析构函数都调用完成后，系统会检查是否还有非空的线程特定数据值与键关联，若有，则再次调用析构函数。这个过程一直重复知道线程所有的键都为空线程特定数据值。这里重复次数受 PTHREAD_DESTRUCTOR_ITERATIONS 限制。</li>
</ol>
<p><strong>2. 取消键与线程特定数据值的关联关系</strong></p>
<p><img src="Snipaste_2022-11-19_17-13-55.png" width="100%" height="100%"></p>
<p>调用 pthread_key_delete 并不会激活与键关联的析构函数。</p>
<p>有些线程可能看到一个键值，而其他线程看到的可能是另一个不同的键值，这取决于系统如何调度线程的。解决这种竞争的方法是使用 pthread_once。</p>
<p><img src="Snipaste_2022-11-19_17-25-31.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-19_17-25-46.png" width="100%" height="100%"></p>
<p>initflag 必须是一个非本地变量（如全局变量或静态变量），且必须初始化为 PTHREAD_ONCE_INIT。</p>
<p>pthread_once() 的作用是：每个线程都调用 pthread_once，系统能保证初始化例程 initfn() 只被调用一次。</p>
<p><img src="Snipaste_2022-11-19_17-28-04.png" width="100%" height="100%"></p>
<p><strong>3. 关联键和线程特定数据</strong></p>
<p><img src="Snipaste_2022-11-19_17-33-08.png" width="100%" height="100%"></p>
<p>pthread_setspecific()：将键和线程特定数据关联起来。<br>pthread_getspecific()：获取线程特定数据地址。若没有线程特定数据值与键关联，则返回 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用线程特定数据维护每个线程的数据缓冲区副本，用于存放个字的返回字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRINGSZ	4096</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> key;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">pthread_mutex_t</span> env_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">thread_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_key_create(&amp;key, <span class="built_in">free</span>); <span class="comment">// 由 free 函数来释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数是线程安全的，但不是异步信号安全。对信号处理程序而言，即使使用递归互斥量，该函数也不能可重入，因为它使用了 malloc 函数，而 malloc 函数本身并不是异步信号安全的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>		i, len;</span><br><span class="line">	<span class="type">char</span>	*envbuf;</span><br><span class="line"></span><br><span class="line">	pthread_once(&amp;init_done, thread_init);</span><br><span class="line">	pthread_mutex_lock(&amp;env_mutex);</span><br><span class="line">	envbuf = (<span class="type">char</span> *)pthread_getspecific(key);</span><br><span class="line">	<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		envbuf = <span class="built_in">malloc</span>(MAXSTRINGSZ);</span><br><span class="line">		<span class="keyword">if</span> (envbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_setspecific(key, envbuf);</span><br><span class="line">	&#125;</span><br><span class="line">	len = <span class="built_in">strlen</span>(name);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strncmp</span>(name, environ[i], len) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		  (environ[i][len] == <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="built_in">strncpy</span>(envbuf, &amp;environ[i][len+<span class="number">1</span>], MAXSTRINGSZ<span class="number">-1</span>);</span><br><span class="line">			pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">			<span class="keyword">return</span>(envbuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;env_mutex);</span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h1><p><strong>可取消状态</strong> 和 <strong>可取消类型</strong> 作为线程属性并没有包含在 pthread_attr_t 中，但它会影响线程在相应 pthread_cancel 函数调用时所呈现的行为。</p>
<p><strong>1. 可取消状态属性</strong></p>
<p>值域：PTHREAD_CANCEL_ENABLE（默认值）、PTHREAD_CANCEL_DISABLE。</p>
<blockquote>
<p>当状态设置为 PTHREAD_CANCEL_DISABLE 时，pthread_cancel() 并不会杀死进程。取消请求对这个线程来说还处于挂起状态，当取消状态再次变为 PTHREAD_CANCEL_ENABLE 时，线程将在下一个取消点上对所有挂起的取消请求进行处理。</p>
</blockquote>
<p>操作函数： pthread_setcancelstate()</p>
<p><img src="Snipaste_2022-11-19_18-57-13.png" width="100%" height="100%"></p>
<p>该函数将当前的可取消状态置为 state，并将原来的可取消状态存储在 oldstate 指向的内存单元，这两步是原子操作。</p>
<p><strong>取消点：</strong> 线程发出的取消请求（调用 pthread_cancel()）只能在线程执行到某个<em>取消点</em>才能检查它是否被取消，若取消才终止线程。</p>
<p>取消点会在如下图所示的函数调用时才会出现：</p>
<p><img src="Snipaste_2022-11-19_19-09-38.png" width="100%" height="100%"></p>
<p><img src="Snipaste_2022-11-19_19-10-21.png" width="100%" height="100%"></p>
<p><strong>手动添加取消点：</strong></p>
<p><img src="Snipaste_2022-11-19_19-15-04.png" width="100%" height="100%"></p>
<p>调用 pthread_testcancel 时，若某个取消请求正处于挂起状态，而且取消并没有置为无效，则线程就会被取消；否则调用无任何效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">void</span>* (*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_time</span><span class="params">(<span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    print_cur_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clean_up1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    print_time(<span class="string">&quot;thread&#x27;s clean-up program is running!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">fn</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    print_time(<span class="string">&quot;fn() is running!&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(clean_up1, <span class="string">&quot;empty arg&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    print_time(<span class="string">&quot;thread is stopping!&quot;</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *) <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;after pthread_exit()&quot;); // pthread_exit() 之后不会被执行到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_thread_state</span><span class="params">(<span class="type">int</span> state)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_CANCEL_ENABLE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread state: PTHREAD_CANCEL_ENABLE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_CANCEL_DISABLE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread state: PTHREAD_CANCEL_DISABLE\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_cancel_point</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> oldstate;</span><br><span class="line"></span><br><span class="line">    create_thread(&amp;tid, fn, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;oldstate);</span><br><span class="line">    print_thread_state(oldstate);</span><br><span class="line">    print_time(<span class="string">&quot;before calling sleep(1)&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    print_time(<span class="string">&quot;calling pthread_cancel()&quot;</span>);</span><br><span class="line">    <span class="comment">// pthread_cancel(tid); // (a)</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    print_time(<span class="string">&quot;after calling sleep(10)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果 （注释行(a)后）</span></span><br><span class="line">thread state: PTHREAD_CANCEL_ENABLE</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">22</span>:<span class="number">28</span>:<span class="number">20</span>: fn() is running!</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-13</span> <span class="number">22</span>:<span class="number">28</span>:<span class="number">20</span>: before calling <span class="title function_">sleep</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">2022-11-13 22:28:21: calling <span class="title function_">pthread_cancel</span><span class="params">()</span></span><br><span class="line">2022-11-13 22:28:25: thread is stopping!		</span><br><span class="line">2022-11-13 22:28:25: thread&#x27;s clean-up program is running!	<span class="comment">// 未调用 pthread_cancel() 时线程晚了 5s 钟停止</span></span><br><span class="line">2022-11-13 22:28:31: after calling <span class="title function_">sleep</span><span class="params">(<span class="number">10</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果 （不注释行(a)）</span></span><br><span class="line">thread state: PTHREAD_CANCEL_ENABLE</span><br><span class="line">2022-11-13 22:34:40: before calling <span class="title function_">sleep</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line">2022-11-13 22:34:40: <span class="title function_">fn</span><span class="params">()</span> is running!</span><br><span class="line">2022-11-13 22:34:41: calling <span class="title function_">pthread_cancel</span><span class="params">()</span></span><br><span class="line">2022-11-13 22:34:41: thread&#x27;s clean-up program is running!	<span class="comment">// 调用 pthread_cancel() 时线程仅晚了 1s 钟停止。原因是 sleep(10) 是一个取消点，执行它时就会检查是否执行了 pthread_cancel，若已执行则取消（终止）线程</span></span><br><span class="line">2022-11-13 22:34:51: after calling <span class="title function_">sleep</span><span class="params">(<span class="number">10</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 取消类型</strong></p>
<ul>
<li>推迟取消（PTHREAD_CANCEL_DEFERRED）<br>调用 pthread_cancel 后，在线程到达取消点之前，并不会真正的取消。</li>
<li>异步取消（PTHREAD_CANCEL_ASYNCHRONOUS）<br>调用 pthread_cancel 后，线程可在任意时间撤销，并不一定非得遇到取消点才被取消。</li>
</ul>
<p><img src="Snipaste_2022-11-19_19-38-43.png" width="100%" height="100%"></p>
<p><strong>参数介绍：</strong><br>type：取消类型<br>oldtype：原来的取消类型</p>
<h1 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h1><ul>
<li><p>每个线程都有自己的信号屏蔽字（可通过 pthread_sigmask() 设置），但信号的处理时进程中所有线程共享的。这意味着：每个线程可以阻塞不同的信号，但若由一个线程修改了某个信号的相关处理行为，其他线程也会共享这个改变后的处理行为。</p>
</li>
<li><p>进程中的信号是递送到单个线程的。若一个信号与硬件故障有关，那么该信号一般会被发送到引起该事件的线程中去，而其他信号则被发送到<strong>任意一个线程</strong></p>
</li>
</ul>
<p><img src="Snipaste_2022-11-20_12-13-11.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>基本与 sigprocmask() 相同，区别是：</p>
<ul>
<li>sigprocmask() 一般用在进程中，线程中一般使用 pthread_sigmask 函数。</li>
<li>sigprocmask 失败时会设置 errno 并返回 -1；pthread_sigmask 失败时返回错误码。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">how 参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIG_BLOCK</td>
<td style="text-align:center">将信号集添加到信号屏蔽字中</td>
</tr>
<tr>
<td style="text-align:center">SIG_SETMASK</td>
<td style="text-align:center">用信号集替换线程的信号屏蔽字</td>
</tr>
<tr>
<td style="text-align:center">SIG_UNBLOCK</td>
<td style="text-align:center">从线程信号屏蔽字中移除信号集</td>
</tr>
</tbody>
</table>
</div>
<p>oset：获取原先的信号屏蔽字，为 NULL 则表示不获取<br>set：为 NULL 时 how 参数无意义。</p>
<p><img src="Snipaste_2022-11-20_12-31-40.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong></p>
<p>挂起正在执行的调用线程，直到参数 set 所指定的信号集中的某个信号处于待处理状态时恢复调用线程的执行。该函数接收待处理的信号，并将其从信号的待处理列表中移除。参数 sig 被设置为该待处理的信号。</p>
<blockquote>
<p>这里的信号处于待处理状态主要指的是触发了该信号。</p>
</blockquote>
<p>sigwait 函数将异步产生的信号用同步的方式处理。为防止信号中断线程， <strong>可以将信号加到每个线程的信号屏蔽字中</strong>。然后使用 <strong>专用线程</strong> 处理信号。这些专用线程可以进行函数调用，而不需要担心在信号处理程序中调用哪些函数是安全的，因为这些函数调用 <strong>来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序</strong>。</p>
<p>若多个线程在 sigwait 的调用中因等待同一个信号而阻塞，那么在信号递送的时候，只有一个线程可以从 sigwait 中返回。</p>
<p>若一个信号被捕获（例如进程通过使用 sigaction 建立了一个信号处理程序），且一个线程正在 sigwait 调用中等待同一个信号，那么将由操作系统实现来决定以何种方式递送信号。一般有两种方式（这两种情况不会同时发生）：</p>
<ul>
<li>让 sigwait 返回</li>
<li>激活信号处理程序</li>
</ul>
<p><strong>参数说明：</strong></p>
<p>set：线程等待的信号集<br>signop：sigwait 接收到的信号值</p>
<div class="tabs" id="sigwait验证"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#sigwait验证-1">验证1</button></li><li class="tab"><button type="button" data-href="#sigwait验证-2">验证2</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="sigwait验证-1"><p><strong>当 sigwait 等待的信号触发时，要么 (a) 让 sigwait 函数返回；要么 (b) 激活信号处理程序；两者不会同时发生</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">void</span>* (*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="keyword">extern</span> Sigfunc *<span class="title function_">my_signal</span><span class="params">(<span class="type">int</span> signo, Sigfunc *func)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 sigwait 等待的信号触发时（这里是 SIGQUIT 与 SIGUSR1），并不会激活信号处理程序</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">my_sig_handler2</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_sig_handler: %s\n&quot;</span>, strsignal(signo)); <span class="comment">// 打印信号描述</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">my_fn3</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread [ %ld ] is running!\n&quot;</span>, pthread_self());</span><br><span class="line">    pthread_exit((<span class="type">void</span> *) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">waitforsig</span><span class="params">(<span class="type">int</span> count, ...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, recvsig, arg;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    va_list valist;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    va_start(valist, count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        arg = va_arg(valist, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%d: %s\n&quot;</span>, arg, strsignal(arg));</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>, arg);</span><br><span class="line">    &#125;    </span><br><span class="line">    va_end(valist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里等待的信号：SIGQUIT、SIGUSR1</span></span><br><span class="line">    <span class="keyword">if</span>(sigwait(&amp;<span class="built_in">set</span>, &amp;recvsig) != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;sigwait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received signal of [%s]\n&quot;</span>, strsignal(recvsig));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waitforsig is finishing!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_sigwait3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process ID = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">if</span>(my_signal(SIGQUIT, my_sig_handler2) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(my_signal(SIGUSR1, my_sig_handler2) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(my_signal(SIGUSR2, my_sig_handler2) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create_thread(&amp;tid, my_fn3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    waitforsig(<span class="number">2</span>, SIGQUIT, SIGUSR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">process ID = <span class="number">13863</span></span><br><span class="line">thread [ <span class="number">140702815987456</span> ] is running!</span><br><span class="line">        <span class="number">3</span>: Quit</span><br><span class="line">        <span class="number">10</span>: User defined signal <span class="number">1</span></span><br><span class="line">received signal of [User defined signal <span class="number">1</span>]	<span class="comment">// 当 sigwait 等待的信号触发时直接让其返回，而不是激活信号处理程序</span></span><br><span class="line">waitforsig is finishing!</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="sigwait验证-2"><ul>
<li><strong>sleep函数说明</strong></li>
<li><strong>多个线程使用 sigwait 等待同一个信号，当信号触发时，只有一个线程从 sigwait 中返回</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">void</span>* (*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="keyword">extern</span> Sigfunc *<span class="title function_">my_signal</span><span class="params">(<span class="type">int</span> signo, Sigfunc *func)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">my_sigmask</span><span class="params">(<span class="type">int</span> count, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">waitforsig</span><span class="params">(<span class="type">int</span> count, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 sigwait 等待的信号触发时（这里是 SIGQUIT 与 SIGUSR1），并不会激活信号处理程序</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">my_sig_handler2</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my_sig_handler: %s\n&quot;</span>, strsignal(signo)); <span class="comment">// 打印信号描述</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">my_fn3</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// my_sigmask(2, SIGQUIT, SIGUSR1);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[ thread: %ld ] is running!\n&quot;</span>, pthread_self());</span><br><span class="line">    waitforsig(<span class="number">2</span>, SIGQUIT, SIGUSR1);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *) <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">waitforsig</span><span class="params">(<span class="type">int</span> count, ...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, recvsig, arg;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    va_list valist;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    va_start(valist, count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        arg = va_arg(valist, <span class="type">int</span>);</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>, arg);</span><br><span class="line">    &#125;    </span><br><span class="line">    va_end(valist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里等待的信号：SIGQUIT、SIGUSR1</span></span><br><span class="line">    <span class="keyword">if</span>(sigwait(&amp;<span class="built_in">set</span>, &amp;recvsig) != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;sigwait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[ thread %ld ] received signal of [%s].\n&quot;</span>, pthread_self() ,strsignal(recvsig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">my_sigmask</span><span class="params">(<span class="type">int</span> count, ...)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, sig;</span><br><span class="line">    va_list vasig;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    va_start(vasig, count);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        sig = va_arg(vasig, <span class="type">int</span>);</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>, sig);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vasig);</span><br><span class="line">    </span><br><span class="line">    pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_sigwait3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3, tid4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[ main thread ] %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面句必须加，否则程序退出。因为主线程不屏蔽这两个信号，也会接收这</span></span><br><span class="line">    <span class="comment">// 两个信号，并执行信号处理程序，直接导致 sleep(100); 失效</span></span><br><span class="line">    my_sigmask(<span class="number">2</span>, SIGQUIT, SIGUSR1); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process ID = %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">if</span>(my_signal(SIGQUIT, my_sig_handler2) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(my_signal(SIGUSR1, my_sig_handler2) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    create_thread(&amp;tid1, my_fn3, <span class="literal">NULL</span>);</span><br><span class="line">    create_thread(&amp;tid2, my_fn3, <span class="literal">NULL</span>);</span><br><span class="line">    create_thread(&amp;tid3, my_fn3, <span class="literal">NULL</span>);</span><br><span class="line">    create_thread(&amp;tid4, my_fn3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">[ main thread ] <span class="number">140085021624128</span></span><br><span class="line">process ID = <span class="number">22306</span></span><br><span class="line">[ thread: <span class="number">140085013247744</span> ] is running!</span><br><span class="line">[ thread: <span class="number">140085004855040</span> ] is running!</span><br><span class="line">[ thread: <span class="number">140084996462336</span> ] is running!</span><br><span class="line">[ thread: <span class="number">140084988069632</span> ] is running!</span><br><span class="line"><span class="comment">// 另一终端执行 for (( i=0;i&lt;100;i++ )) ; do kill -usr1 22306; done 后的输出结果如下</span></span><br><span class="line">[ thread <span class="number">140084996462336</span> ] received signal of [User defined signal <span class="number">1</span>].</span><br><span class="line">[ thread <span class="number">140085013247744</span> ] received signal of [User defined signal <span class="number">1</span>].</span><br><span class="line">[ thread <span class="number">140085004855040</span> ] received signal of [User defined signal <span class="number">1</span>].</span><br><span class="line">[ thread <span class="number">140084988069632</span> ] received signal of [User defined signal <span class="number">1</span>].</span><br><span class="line"><span class="comment">// 程序输出如上结果后并不退出，这是因为主线程阻塞了 SIGUSR1 的递送</span></span><br></pre></td></tr></table></figure>
<p><strong>关于 sleep() 的详细说明：</strong><br>   Make the process sleep for SECONDS seconds, or until a signal arrives<br>   and is not ignored.  The function returns the number of seconds less<br>   than SECONDS which it actually slept (thus zero if it slept the full time).<br>   If a signal handler does a <code>longjmp&#39; or modifies the handling of the
   SIGALRM signal while inside</code>sleep’ call, the handling of the SIGALRM<br>   signal afterwards is undefined.  There is no return value to indicate<br>   error, but if `sleep’ returns SECONDS, it probably didn’t work.</p>
<p>   This function is a cancellation point and therefore not marked with<br>   __THROW.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>调用 sigwait 前必须阻塞其等待的信号。若等待的信号被忽略，则 sigwait 将永远等待下去。只要等待的信号集中有一个信号到达 sigwait 就返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_tid2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    tid = pthread_self();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid %lu tid %lu (0x%lx)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)pid,</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>)tid, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************/</span></span><br><span class="line"><span class="comment">// 进程阻塞信号：SIGINT，SIGUSR1</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">block_sig_in_proc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置阻塞的信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGUSR2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在调用 sigwait 前必须阻塞其等待的信号</span></span><br><span class="line">    <span class="comment">// if(sigprocmask(SIG_BLOCK, &amp;set, &amp;oset) &lt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//     my_err_exit(&quot;sigprocmask error&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset) != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;pthread_sigmask error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">print_thread_mask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> oset;</span><br><span class="line">    pthread_sigmask(<span class="number">0</span>, <span class="literal">NULL</span>, &amp;oset);</span><br><span class="line">    print_tid2();</span><br><span class="line">    pr_mask(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">waitfor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> signop;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGUSR2);</span><br><span class="line">    <span class="keyword">if</span>(sigwait(&amp;<span class="built_in">set</span>, &amp;signop) != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;sigwait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;signop = %d\n&quot;</span>, signop);</span><br><span class="line">    print_thread_mask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************** 线程 1 **************************/</span></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">start_fn1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* myarg = (<span class="type">int</span>*) arg;</span><br><span class="line">    print_tid2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg = %d\n&quot;</span>, *myarg);</span><br><span class="line">    waitfor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************** 线程 2 **************************/</span></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">start_fn2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* myarg = (<span class="type">int</span>*) arg;</span><br><span class="line">    print_tid2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg = %d\n&quot;</span>, *myarg);</span><br><span class="line">    waitfor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">test_sigwait</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">pthread_t</span> t1,t2;</span><br><span class="line">    <span class="type">int</span> arg1 = <span class="number">1</span>, arg2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    block_sig_in_proc(); <span class="comment">// 主进程创建出来的线程将继承主进程的掩码</span></span><br><span class="line">    print_thread_mask();</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;t1, <span class="literal">NULL</span>, start_fn1, &amp;arg1);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;pthread_create err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;t2, <span class="literal">NULL</span>, start_fn2, &amp;arg2);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;pthread_create err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitfor();</span></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// print_thread_mask();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">pid <span class="number">6119</span> tid <span class="number">140342998984512</span> (<span class="number">0x7fa42699e740</span>)	<span class="comment">//主线程</span></span><br><span class="line"> SIGQUIT SIGUSR1 SIGUSR2</span><br><span class="line">pid <span class="number">6119</span> tid <span class="number">140342990608128</span> (<span class="number">0x7fa4261a1700</span>)	<span class="comment">// 线程 1</span></span><br><span class="line">arg = <span class="number">1</span></span><br><span class="line">pid <span class="number">6119</span> tid <span class="number">140342982215424</span> (<span class="number">0x7fa4259a0700</span>)	<span class="comment">// 线程 2</span></span><br><span class="line">arg = <span class="number">2</span></span><br><span class="line"><span class="comment">// 另一个终端中执行 kill -USR2 6119</span></span><br><span class="line">signop = <span class="number">12</span></span><br><span class="line">pid <span class="number">6119</span> tid <span class="number">140342990608128</span> (<span class="number">0x7fa4261a1700</span>)	<span class="comment">//线程 1 信号屏蔽字</span></span><br><span class="line"> SIGQUIT SIGUSR1 SIGUSR2</span><br><span class="line"><span class="comment">// 另一个终端中执行 kill -USR1 6119 </span></span><br><span class="line">signop = <span class="number">10</span></span><br><span class="line">pid <span class="number">6119</span> tid <span class="number">140342982215424</span> (<span class="number">0x7fa4259a0700</span>)	<span class="comment">// 线程 2 的信号屏蔽字</span></span><br><span class="line"> SIGQUIT SIGUSR1 SIGUSR2</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>			quitflag;	<span class="comment">/* set nonzero by thread */</span></span><br><span class="line"><span class="type">sigset_t</span>	mask;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> waitloc = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn4</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err, signo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// sigwait 会解除信号的阻塞状态，所以只有一个线程用于信号的接收，不用担心主线程会被这些信号中断</span></span><br><span class="line">		err = sigwait(&amp;mask, &amp;signo);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			err_exit(err, <span class="string">&quot;sigwait failed&quot;</span>);</span><br><span class="line">		<span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">		<span class="keyword">case</span> SIGINT:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\ninterrupt\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SIGQUIT:</span><br><span class="line">			pthread_mutex_lock(&amp;lock);</span><br><span class="line">			quitflag = <span class="number">1</span>;</span><br><span class="line">			pthread_mutex_unlock(&amp;lock);</span><br><span class="line">			pthread_cond_signal(&amp;waitloc);</span><br><span class="line">			<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;unexpected signal %d\n&quot;</span>, signo);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_sigwait2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			err;</span><br><span class="line">	<span class="type">sigset_t</span>	oldmask;</span><br><span class="line">	<span class="type">pthread_t</span>	tid;</span><br><span class="line"></span><br><span class="line">	sigemptyset(&amp;mask);</span><br><span class="line">	sigaddset(&amp;mask, SIGINT);</span><br><span class="line">	sigaddset(&amp;mask, SIGQUIT);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, &amp;oldmask)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;SIG_BLOCK error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用专门的独立的控制线程进行信号处理</span></span><br><span class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn4, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;lock);</span><br><span class="line">	<span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">		pthread_cond_wait(&amp;waitloc, &amp;lock);</span><br><span class="line">	pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SIGQUIT has been caught and is now blocked; do whatever */</span></span><br><span class="line">	quitflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reset signal mask which unblocks SIGQUIT */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		err_sys(<span class="string">&quot;SIG_SETMASK error&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^C</span><br><span class="line">interrupt</span><br><span class="line">^\%</span><br></pre></td></tr></table></figure>
<p><img src="Snipaste_2022-11-21_12-19-39.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong></p>
<ul>
<li>可传递一个 0 值的 signo 来检查线程是否存在</li>
<li>若信号的默认处理是终止该线程，那么把信号传递给某个线程仍然会杀死整个进程</li>
<li>闹钟定时器是进程资源，所有的线程共享相同的闹钟。</li>
</ul>
<hr>
<div class="tabs" id="补充例子"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#补充例子-1">主程序</button></li><li class="tab"><button type="button" data-href="#补充例子-2">主程序用到的外部函数</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="补充例子-1"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程与子线程共用同一个进程 ID。当向该进程 ID 发送信号时，进程中的所有线程都可以接收到信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pr_mask</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">my_print_tid</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">void</span>* (*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line">Sigfunc *</span><br><span class="line"><span class="title function_">my_signal</span><span class="params">(<span class="type">int</span> signo, Sigfunc *func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oact</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = func;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, signo);</span><br><span class="line"></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(signo == SIGALRM) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SA_INTERRUPT</span></span><br><span class="line">        act.sa_flags |= SA_INTERRUPT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        act.sa_flags |= SA_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(signo, &amp;act, &amp;oact) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SIG_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oact.sa_handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">fn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    my_print_tid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: thread1 is running!\tgetpid(): %d\n&quot;</span>, getpid());</span><br><span class="line">    pause();</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">fn2</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    my_print_tid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: thread2 is running!\tgetpid(): %d\n&quot;</span>, getpid());</span><br><span class="line">    pause();</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> fd, bfd;</span><br><span class="line"></span><br><span class="line">    my_print_tid();</span><br><span class="line">    pr_mask(<span class="string">&quot;: 信号处理程序 sig_func: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_thread_signal</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">sigset_t</span> sigset, osigset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    my_print_tid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: main thread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定义 SIGQUIT 信号</span></span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_signal(SIGQUIT, sig_func) == SIG_ERR) &#123;</span><br><span class="line">        my_err_exit(<span class="string">&quot;my_signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    create_thread(&amp;tid1, fn1, <span class="literal">NULL</span>);</span><br><span class="line">    create_thread(&amp;tid2, fn2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 等待两个子线程成功运行并 pause() 等待信号到达</span></span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nret1 = %d\n&quot;</span>, ret);</span><br><span class="line">    pthread_join(tid2, &amp;ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret2 = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 for ((i=0;i&lt;100;i++)) ; do kill -QUIT 9567 done; 的运行结果</span></span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): main thread</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): thread1 is running!      getpid(): <span class="number">9567</span></span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>): thread2 is running!      getpid(): <span class="number">9567</span></span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func: pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>) SIGQUIT: 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>)pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line"></span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func: : 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>): 信号处理程序 sig_func: pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>) SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line"> SIGQUIT</span><br><span class="line">: 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093972662016</span> (<span class="number">0x7f6a2b79c700</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093981038400</span> (<span class="number">0x7f6a2bf99740</span>): 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">pid <span class="number">9567</span> tid <span class="number">140093964269312</span> (<span class="number">0x7f6a2af9b700</span>)</span><br><span class="line">ret1 = <span class="number">1</span></span><br><span class="line">: 信号处理程序 sig_func:  SIGQUIT</span><br><span class="line">ret2 = <span class="number">2</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="补充例子-2"><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">my_print_tid</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    tid = pthread_self();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid %lu tid %lu (0x%lx)&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)pid,</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>)tid, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pr_mask</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">sigset_t</span>	sigset;</span><br><span class="line">	<span class="type">int</span>			errno_save;</span><br><span class="line"></span><br><span class="line">	errno_save = errno;		<span class="comment">/* we can be called by signal handlers */</span></span><br><span class="line">	<span class="keyword">if</span> (sigprocmask(<span class="number">0</span>, <span class="literal">NULL</span>, &amp;sigset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_ret(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> (sigismember(&amp;sigset, SIGINT))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; SIGINT&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (sigismember(&amp;sigset, SIGQUIT))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; SIGQUIT&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (sigismember(&amp;sigset, SIGUSR1))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; SIGUSR1&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (sigismember(&amp;sigset, SIGUSR2))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; SIGUSR2&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (sigismember(&amp;sigset, SIGALRM))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; SIGALRM&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* remaining signals can go here  */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	errno = errno_save;		<span class="comment">/* restore errno */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">create_thread</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">void</span>* (*fn)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    err = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_attr_init() failed: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_attr_setdetachstate() failed: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_create(tid, &amp;attr, fn, arg);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create() failed: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_attr_destroy() failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h1 id="线程和-fork"><a href="#线程和-fork" class="headerlink" title="线程和 fork"></a>线程和 fork</h1><p>当线程调用 fork 时，采用<strong>写时复制</strong>的方式创建整个进程的地址空间。只要父子进程对内存都没做改动，则父子进程共享内存页的副本。<br>因此，子进程继承了父进程的所有互斥量、读写锁、条件变量的状态。问题是子进程继承这些锁是父进程的一个副本，因此子进程没办法知道它占有了哪些锁，需要释放哪些锁。 <strong>若父进程包含一个以上的线程，子进程在 fork 返回后，若紧接着不是马上调用 exec 的话，就需要清理锁状态</strong>。<br>若子进程从 fork 返回后马上调用其中一个 exec 函数，旧的地址空间就被丢弃，因此就不需要关心锁的状态。若子进程仍旧需要继续做处理工作的话，这种策略也是不行。</p>
<p>在多线程的进程中，为了避免不一致状态的问题，POSIX.1 声明：<strong>在 fork 返回和子进程调用其中一个 exec 函数之间，子进程只能调用异步信号安全的函数</strong>。</p>
<p><img src="Snipaste_2022-11-21_19-53-04.png" width="100%" height="100%"></p>
<p><strong>函数说明：</strong><br>安装解除锁状态的处理函数。对应参数为 NULL 表示不安装该处理程序。</p>
<ul>
<li>prepare：由父进程在 fork 创建子进程前调用。任务是获取父进程定义的所有锁。</li>
<li>parent：在 fork 创建子进程以后、返回之前在<strong>父进程上下文</strong>中调用的。任务是：对 prepare 阶段获取的所有锁进行解锁。</li>
<li>child：在 fork 返回之前在<strong>子进程上下文</strong>中调用。任务是：必须释放 prepare 阶段获取的锁。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock2 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prepare</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;preparing locks...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lock1 = %x\tlock2 = %x\n&quot;</span>, lock1, lock2);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_lock(&amp;lock1)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t lock lock1 in prepare handler&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_lock(&amp;lock2)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t lock lock2 in prepare handler&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">parent</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lock1 = %x\tlock2 = %x\n&quot;</span>, lock1, lock2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent unlocking locks...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_unlock(&amp;lock1)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t unlock lock1 in parent handler&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_unlock(&amp;lock2)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t unlock lock2 in parent handler&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">child</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child unlocking locks...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_unlock(&amp;lock1)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t unlock lock1 in child handler&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_mutex_unlock(&amp;lock2)) != <span class="number">0</span>)</span><br><span class="line">		err_cont(err, <span class="string">&quot;can&#x27;t unlock lock2 in child handler&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">thr_fn5</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread started...\n&quot;</span>);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">test_pthread_atfork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>			err;</span><br><span class="line">	<span class="type">pid_t</span>		pid;</span><br><span class="line">	<span class="type">pthread_t</span>	tid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_atfork(prepare, parent, child)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t install fork handlers&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn5, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">		err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent about to fork...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">		err_quit(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)	<span class="comment">/* child */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child returned from fork\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>		<span class="comment">/* parent */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent returned from fork\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">thread started...</span><br><span class="line">parent about to fork...</span><br><span class="line">preparing locks...</span><br><span class="line">lock1 = f7ff8000        lock2 = f7bbaa00</span><br><span class="line">lock1 = f7bb8760        lock2 = <span class="number">4045b</span>8</span><br><span class="line">parent unlocking locks...</span><br><span class="line">parent returned from fork</span><br><span class="line">child unlocking locks...</span><br><span class="line">child returned from fork</span><br></pre></td></tr></table></figure>
<p>pthread_atfork 可被调用多次，添加多套 fork 处理程序，调用顺序是：parent 和 child 是以它们注册时的顺序进行调用；prepare 的调用顺序与它们注册的顺序相反。</p>
<p>对于条件变量而言，有些操作系统的实现中，条件变量不用清理；有个操作系统将锁作为实现条件变量的一部分，这时就需要清理。遗憾的是并没有清理锁的接口。</p>
<p>pthread_atfork 的不足：</p>
<p><img src="Snipaste_2022-11-21_20-41-54.png" width="100%" height="100%"></p>
<h1 id="线程和-IO"><a href="#线程和-IO" class="headerlink" title="线程和 IO"></a>线程和 IO</h1><p>由于进程中所有的线程共用相同的文件描述符。因此在多线程环境下对同一个文件的读写可能会有并发问题。解决方案是使用 pread 和 pwrite 函数。原因是它们的操作被封装为原子性的，同一时刻只有一个线程执行 pread 或 pwrite。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS">YFS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jeckfs.gitee.io/JeckFS/2022/11/17/Unix-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">http://jeckfs.gitee.io/JeckFS/2022/11/17/Unix-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeckfs.gitee.io/JeckFS" target="_blank">JeckFS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/JeckFS/tags/Unix/">Unix</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=3747114911,414713113&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=882&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/JeckFS/2022/11/21/Unix-%E7%BB%88%E7%AB%AFIO/"><img class="prev-cover" src="https://img1.baidu.com/it/u=2860717797,2343059675&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unix-终端IO</div></div></a></div><div class="next-post pull-right"><a href="/JeckFS/2022/11/15/Unix-%E7%BA%BF%E7%A8%8B/"><img class="next-cover" src="https://img1.baidu.com/it/u=2656997690,163773951&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/JeckFS/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix-线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/JeckFS/2022/11/22/Unix-%E4%BC%AA%E7%BB%88%E7%AB%AF/" title="Unix-伪终端"><img class="cover" src="https://img2.baidu.com/it/u=208782341,2933630295&fm=253&fmt=auto&app=120&f=JPEG?w=641&h=361" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Unix-伪终端</div></div></a></div><div><a href="/JeckFS/2022/12/02/Unix-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/" title="Unix-文件和目录"><img class="cover" src="https://img1.baidu.com/it/u=283250001,79199516&fm=253&fmt=auto&app=120&f=JPEG?w=1200&h=674" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="title">Unix-文件和目录</div></div></a></div><div><a href="/JeckFS/2022/12/01/Unix-%E6%96%87%E4%BB%B6IO/" title="Unix-文件IO"><img class="cover" src="https://img0.baidu.com/it/u=3798217922,3880088897&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-01</div><div class="title">Unix-文件IO</div></div></a></div><div><a href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试"><img class="cover" src="https://img1.baidu.com/it/u=2322041376,2548191196&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-29</div><div class="title">gdb-调试</div></div></a></div><div><a href="/JeckFS/2022/11/22/Unix-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" title="Unix-守护进程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Unix-守护进程</div></div></a></div><div><a href="/JeckFS/2022/11/21/Unix-%E7%BB%88%E7%AB%AFIO/" title="Unix-终端IO"><img class="cover" src="https://img1.baidu.com/it/u=2860717797,2343059675&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-21</div><div class="title">Unix-终端IO</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/JeckFS/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YFS</div><div class="author-info__description">快乐每一天</div></div><div class="card-info-data site-data is-center"><a href="/JeckFS/archives/"><div class="headline">文章</div><div class="length-num">249</div></a><a href="/JeckFS/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/JeckFS/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%99%90%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">线程限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">线程属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">同步属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">互斥量属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">读写锁属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">条件变量属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">屏障属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">重入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">线程特定数据 &#x2F; 线程私有数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E9%80%89%E9%A1%B9"><span class="toc-number">6.</span> <span class="toc-text">取消选项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.</span> <span class="toc-text">线程和信号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C-fork"><span class="toc-number">8.</span> <span class="toc-text">线程和 fork</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C-IO"><span class="toc-number">9.</span> <span class="toc-text">线程和 IO</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试"><img src="https://img1.baidu.com/it/u=2322041376,2548191196&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="gdb-调试"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/29/gdb-%E8%B0%83%E8%AF%95/" title="gdb-调试">gdb-调试</a><time datetime="2022-12-29T03:33:44.000Z" title="发表于 2022-12-29 11:33:44">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧"><img src="https://img0.baidu.com/it/u=3798217922,3880088897&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="vim-使用技巧"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/23/vim-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="vim-使用技巧">vim-使用技巧</a><time datetime="2022-12-23T04:09:28.000Z" title="发表于 2022-12-23 12:09:28">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点"><img src="https://img1.baidu.com/it/u=4132836557,2626223199&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="NAS-SAN异同点"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/12/NAS-SAN%E5%BC%82%E5%90%8C%E7%82%B9/" title="NAS-SAN异同点">NAS-SAN异同点</a><time datetime="2022-12-12T02:06:26.000Z" title="发表于 2022-12-12 10:06:26">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC"><img src="https://img1.baidu.com/it/u=2860717797,2343059675&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-高级IPC"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/10/Unix-%E9%AB%98%E7%BA%A7IPC/" title="Unix-高级IPC">Unix-高级IPC</a><time datetime="2022-12-10T03:55:57.000Z" title="发表于 2022-12-10 11:55:57">2022-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets"><img src="https://img1.baidu.com/it/u=2598981474,2305186611&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/JeckFS/img/404.jpg'" alt="Unix-网络IPC-Sockets"/></a><div class="content"><a class="title" href="/JeckFS/2022/12/07/Unix-%E7%BD%91%E7%BB%9CIPC-Sockets/" title="Unix-网络IPC-Sockets">Unix-网络IPC-Sockets</a><time datetime="2022-12-07T05:37:59.000Z" title="发表于 2022-12-07 13:37:59">2022-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YFS</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/JeckFS/js/utils.js"></script><script src="/JeckFS/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/JeckFS/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>